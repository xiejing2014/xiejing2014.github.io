<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用不同语言来遍历目录和文件]]></title>
    <url>%2F2018%2F05%2F18%2F%E7%94%A8%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E6%9D%A5%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近翻移动硬盘，发现自己还短暂的写过两个月的perl语言，盘中赫然躺着一些perl脚本，其中一个便是实现的遍历目录及其包含的文件的脚本。该功能无非就是利用递归来写代码，这里想用perl、python、shell和C语言分别对其进行编写，聊发少年狂而已。 程序列表12345678[root@localhost script]# ls -tlrtotal 28-rwxr--r--. 1 root root 276 May 17 19:16 shell_find.sh-rwxr--r--. 1 root root 444 May 17 19:17 python_find.py-rwxr--r--. 1 root root 782 May 17 19:18 perl_find.sh-rw-r--r--. 1 root root 1184 May 17 19:36 C_Find.c-rwxr-xr-x. 1 root root 9048 May 17 19:37 C_Find[root@localhost script]# 1、perl123456789101112131415161718192021222324252627282930313233#! /usr/bin/perluse strict;my @filelist;my $dir = &quot;../python&quot;;push(@filelist,&amp;findfile($dir));print join(&quot;\n&quot;,@filelist);print &quot;\n&quot;;sub findfile&#123; my @filelist; my $dir = $_[0]; opendir(DIR,$dir); my @temp = grep(!/^\.\.?$/,readdir(DIR)); close(DIR); my $count = @temp; my $i; my $tmpdir; for($i = 0; $i &lt; $count; $i++)&#123; $tmpdir = (); $tmpdir = &quot;$dir/$temp[$i]&quot;; if(-d &quot;$tmpdir&quot;)&#123; push(@filelist,$tmpdir); push(@filelist,&amp;findfile(&quot;$tmpdir&quot;)); &#125; else &#123; push(@filelist,$tmpdir); &#125; &#125; return @filelist; &#125; 2、python123456789101112131415161718#! /usr/bin/python3# coding=utf-8import osbasedir = &apos;../python&apos;filelists = []def find(basedir): global filelists for parent,dirnames,filenames in os.walk(basedir): for dirname in dirnames: filelists.append(os.path.join(parent,dirname)) for filename in filenames: filelists.append(os.path.join(parent,filename))if __name__ == &apos;__main__&apos;: find(basedir) print(&apos;\n&apos;.join(filelists)) 3、shell12345678910111213141516171819#! /usr/bin/bashset -o nounsetset -o errexitfunction find()&#123; for file in `ls $1` do if [ -d $1&quot;/&quot;$file ] then echo $1&quot;/&quot;$file find $1&quot;/&quot;$file else echo $1&quot;/&quot;$file fi done&#125;find &quot;../python&quot; 4、 C源代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* list dir and files through C */ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#define MAX_PATH_LENGTH 512 int find(char *path)&#123; DIR *ptr_dir; struct dirent *dir_entry; int i = 0; char *child_path; child_path = (char*)malloc(sizeof(char)*MAX_PATH_LENGTH); if(child_path == NULL)&#123; printf(&quot;malloc child_path occurs errors.\n&quot;); exit(1); &#125; memset(child_path,0x0,sizeof(char)*MAX_PATH_LENGTH); ptr_dir = opendir(path); while(( dir_entry = readdir(ptr_dir) ) != NULL)&#123; if(dir_entry-&gt;d_type &amp; DT_DIR)&#123; if(strcmp(dir_entry-&gt;d_name,&quot;.&quot;) == 0 || strcmp(dir_entry-&gt;d_name,&quot;..&quot;) == 0)&#123; continue; &#125; sprintf(child_path,&quot;%s/%s&quot;,path,dir_entry-&gt;d_name); printf(&quot;%s\n&quot;,child_path); find(child_path); &#125; else &#123; printf(&quot;%s/%s\n&quot;,path,dir_entry-&gt;d_name); &#125; &#125; free(child_path); child_path = NULL; return 0;&#125;int main()&#123; find(&quot;../python&quot;); return 0;&#125; 编译：1gcc -o C_Find C_Find.c 执行结果上述代码执行结果一致，输出文件列表的默认排序或有差别。以shell脚本的执行结果为例，输出如下：123456789101112131415161718192021222324252627[root@localhost script]# ./shell_find.sh ../python/countCodeLine2.py../python/countCodeLine.py../python/countCodeLine.py_ori../python/Django../python/How_to_be_pythonic../python/How_to_be_pythonic/add.c../python/How_to_be_pythonic/adder.so../python/How_to_be_pythonic/app_decrator.py../python/How_to_be_pythonic/cpython_api.py../python/How_to_be_pythonic/cpython_ctype.py../python/How_to_be_pythonic/cpython_SWIG.py../python/How_to_be_pythonic/debug.txt../python/How_to_be_pythonic/decrator.py../python/How_to_be_pythonic/def__.py../python/How_to_be_pythonic/enumerate.py../python/How_to_be_pythonic/exception.py../python/How_to_be_pythonic/forelse.py../python/How_to_be_pythonic/funccode1.py../python/How_to_be_pythonic/Generators.py../python/How_to_be_pythonic/kw-args.py../python/How_to_be_pythonic/out.log../python/How_to_be_pythonic/pprint.py../python/How_to_be_pythonic/set.py../python/How_to_be_pythonic/test3.py../python/How_to_be_pythonic/test.py[root@localhost script]# 后记 C语言的实现方法中，有关dirent、stat等结构体含义的描述，可参见： http://www.360doc.com/content/15/0701/10/5470123_481878714.shtml 代码中输出的是目录及文件，可调整。 对列出的文件可做进一步的条件筛选，如后缀判断等。 可比较时间，可优化。 本文原作者:不出名的刀客，转载请一同转发本文链接。 第一次网上写技术文，文有不对之处，欢迎指正。 另，小白正在学习python，欢迎大神留言指教。]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>perl</tag>
        <tag>python</tag>
        <tag>shell</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clearcase常用命令]]></title>
    <url>%2F2018%2F05%2F12%2Fclearcase%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常规操作最基本的操作cleartool co -nc xxx.cppcleartool ci -nc xxx.cpp 查看自己总共co了多少文件cleartool lscheckout -cview -me -avobs 最有用的命令cleartool man xxxcleartool help xxx 新增目录和文件cleartool mkdir -c comment new_dircleartool mkelem -c comment new_file.cpp 放弃co某个文件cleartool unco -keep file.cpp //保留当前所改动的文件cleartool unco -rm file.cpp 主线、分支文件合并//查找需要合并的文件cleartool findmerge . -fversion /main/xxxx_path -print//比较文件不同cleartool diff file.cpp file.cpp@@/main/xxxx_path/LATEST//查看最新版本cleartool lsvtree file.cpp//合并cleartool merge -to file.cpp file.cpp@@/main/xxxx_path/LATEST file.cpp@@/main/LATEST 标签相关//新建标签cleartool mklbtype -nc TEST_LABEL//给文件打标签cleartool mklabel -r TEST_LABEL file.cpp//删除标签cleartool rmtype lbtype:TEST_LABEL//给所有打上TEST_LABEL标签的文件打上TEST_LABEL2标签cleartool mklabel -replace -version /main/TEST_LABEL TEST_LABEL2 *//查找打上TEST_LABEL标签的所有文件cleartool find . -version “lbtype(TEST_LABEL)” -print//查找打上TEST_LABEL和TEST_LABEL2标签的文件cleartool find . -element ‘lbtype_sub(TEST_LABEL) &amp;&amp; lbtype_sub(TEST_LABEL2)’ -print 将整个目录导入clearcaseclearfsimport -recurse /xxx/xxx/xxx/src /view/zhuj/home/vobs/cc_account/xxx/xxx/xxx/src目录（包括此目录下的所有目录和文件）被导入/view/zhuj/home/vobs/cc_account中（/view/zhuj/home/vobs/cc_account/src） clearcase常用命令集锦将整个目录导入clearcaseclearfsimport -r‘源路径’ ‘目标路径’ 加锁find . -name ‘.‘ -exec ‘cleartool lock nuser userame1,username2 “%CLEARCASE_PN%”‘ 解锁find . -name ‘.‘ -exec ‘cleartool unlock “%CLEARCASE_PN%”‘ 转换格式chtype -f compressed_file “fileName” 查看VOB的基本信息和UUIDdes -l vob:. 删除视图rmview -uuid “UUID” 删除lost+foundfind . -name ‘.‘ -exec ‘cleartool rmelem -f “%CLEARCASE_PN%”‘ 查询某一天的修改记录cleartool lshis -r -since 07-dec 最基本的操作cleartool co -nc filenamecleartool ci -nc filename 查看自己总共co了多少文件cleartool lscheckout -cview –me -vobs make目录和文件cleartool mkdir -c comment newdirectorycleartool mkelem -c comment newfilename 主线、分支文件合并//查找需要合并的文件cleartool findmerge . -fversion /main/TEST_Path -print//比较文件不同cleartool diff filename [url=mailto:file.cpp@@/main/xxxx_path/LATEST]filename@@/main/TEST_Path/LATEST//查看最新版本cleartool lsvtree filename//合并cleartool merge -to filename [url=mailto:file.cpp@@/main/xxxx_path/LATEST]filename @@/main/TEST_path/LATEST [url=mailto:file.cpp@@/main/LATEST]filename @@/main/LATEST 标签相关cleartool mklbtype -nc TEST_LABELcleartool mklabel -r TEST_LABEL filenamecleartool rmtype lbtype:TEST_LABEL//给所有打上TEST_LABEL标签的文件打上TEST_LABEL标签cleartool mklabel -replace -version /main/TEST_LABEL TEST_LABEL *//查找打上TEST_LABEL标签的所有文件cleartool find . -version “lbtype(TEST_LABEL)” -print//查找打上TEST_LABEL和TEST_LABEL1标签的文件cleartool find . -element ‘lbtype_sub(TEST_LABEL) &amp;&amp; lbtype_sub(TEST_LABEL1)’ -print 察看某目录下的文件ls man/help命令cleartool man xxxcleartool help xxx 放弃co某个文件cleartool unco -keep filenamecleartool unco -rm filename 更改VOB的Owner:cleartool protectvob –chown root /vob/vob.vbs 更改VOB的Group:cleartool protectvob –chgrp alluser /vob/vob.vbs 增加Additional Group:cleartool protectvob –add_group group1 /vob/vob.vbs 删除Additional Group:cleartool protectvob –delete_group group1 /vob/vob.vbs 更改group、owner、modprotect -r -chgrp groupname–chown username -chmod 770 . 创建VOBcleartool mkvob -tag /vobtags/test_code -c “Test” “D:\Data\Tets.vbs” Mount vobCleartool mount /vobtags/vob 创建视图cleartool mkview –tag test /ccvob/views/test.vws 设置当前视图cleartool setview test 设置当前的activitycleartool setactivity activityname Check outCheck out一个文件 Cleartool checkout [-reserve][-unreserve] filename Check out前目录 Cleartool checkout . Check out当前目录下所有文件 Cleartool Checkout –nc . Check out当前目录下所有的文件和目录中的文件 cleartool find . $file -exec ‘cleartool checkout -nc $CLEARCASE_PN’ Check inCheck in 一个文件 Cleartool checkin filename Check in 当前目录Cleartool checkin . Check in 当前目录下所有文件. Cleartool Checkin –nc . Check in当前目录下所有的文件和目录中的文件 cleartool find . $file -exec ‘cleartool checkin -nc –ide $CLEARCASE_PN’ 以上内容来自：http://hi.baidu.com/is%CC%EC%B2%C5/blog/item/36bfbfc83cced1117f3e6fa0.html 常用命令创建view：clt mkview -tag view_abcd /view_store/view_abcd.vws设置view: clt setview view_abcd编辑config specification: clt edcs 创建branch type：clt mkbrtype dbg_branch1_comments在某个文件的当前branch上， 拉出一个branch：clt mkbranch dbg_branch1_comments filename.c now you have make branch on the file, and checked it out.you can edit it with gvim.After changed codes, you can complie it successfully, and test the result, you can check it in.clt ci filename.cIf you want to check out it again:clt co filename.c To change the branch name to a formula name you can use the command:clt rename brtype:dbg_branch1_comments brtype:crnumber_branch1_comments To see the version tree of a file:clt lsvtree -g filename.c To see which files is included in a branch, you can edit a script like this find_branch.sh: echo “$1”cleartool find -avobs -element “brtype(“$1”)” -nxn -print | xargs cleartool ls -s|grep “$1” To compare files, I write a useful script file mydiff. You can use xcc&amp; to open graphic clearcase. So you can do most thing through the menu. 以上内容来自：http://www.diybl.com/course/4_webprogram/asp.net/netjs/20071020/78573.html clearcase实用命令查找分支上的文件find . -branch brtype(branchname) -print创建分支mkbrtype -c “comment” branchname创建Labelmklbtype -c “comment” labelname用于 cleartool find 查询:cleartool find -all -version “lbtype(REL1)” -printfind . -version ‘lbtype(LABEL)’ -print锁分支命令lock brtype:branchname创建triggertrigger已存在mktrtype mktrtype -replace -element -all -preop mkelem -nusers shiquan -exec http://www.cnblogs.com/samcn/admin/file://192.168.1.5/cc_trigger/false.bat NO_RM_MKtrigger不存在mktrtype mktrtype -element -all -preop mkelem -nusers shiquan -exec http://www.cnblogs.com/samcn/admin/file://192.168.1.5/cc_trigger/false.bat NO_RM_MK日常开发人员常用命令 开发人员常用命令建立vobmkvob –tag /vobtags/vob1 –c “ VOB for project1” /vobstore/vob1.vbs Mount vobCleartool mount /vobtags/vob1 创建视图cleartool mkview –tag test1 /ccvob/views/test1.vws 设置当前视图cleartool setview test1 在VOB的根目录下到入数据：clearfsimport –recurse –c “ comments “ /home/setup/* . ，注意命令的最后为圆点，表示当前目录。 改变VOB的Owner:cleartool protectvob –chown root /vobstore/vob1.vbs 改变VOB的Group:cleartool protectvob –chgrp alluser /vobstore/vob1.vbs 增加Additional Group:cleartool protectvob –add_group group1 /vobstore/vob1.vbs 删除Additional Group:cleartool protectvob –delete_group group1 /vobstore/vob1.vbs修改vob中数据的权限信息 将jmccboss VOB 中所有元素Owner 改成ccadmin，Group改成jmccboss:Cleartool protect –chown ccadmin –chgrp jmccboss ..为vob根目录 将jmccboss VOB 中所有元素权限 改成对ccadmin（rwx），jmccboss(rwx)，其他VOB附属组成员（r-x）:例： Cleartool protect –recurse –chmod 775 . ， Mount vobCleartool mount /vobtags/vob1 创建视图cleartool mkview –tag test1 /ccvob/views/test1.vws 设置当前视图cleartool setview test1 在VOB的根目录下到入数据：clearfsimport –recurse –c “ comments “ /home/setup/* . ，注意命令的最后为圆点，表示当前目录。 Check outCleartool checkout [-reserve][-unreserve] b.c Check out一个文件Cleartool checkout . Check out当前目录Cleartool Checkout –nc . Check out当前目录下所有文件cleartool find . $file -exec ‘cleartool checkout -nc $CLEARCASE_PN’Check out当前目录下所有的文件和目录中的文件 Check inCleartool checkin b.c Check in 一个文件Cleartool checkin . Check in 当前目录Cleartool Checkin –nc . Check in 当前目录下所有文件.cleartool find . $file -exec ‘cleartool checkin -nc –ide $CLEARCASE_PN’Check in当前目录下所有的文件和目录中的文件 建立一个snapshot viewcleartool mkview –tag pat_2_snapshot_view –snapshot /viewstore/pat/myviews.vws 编辑config speCleartool edcs 更新snapshot viewcleartool update pat_2_snapshot_view 设置当前的activitycleartool setactivity activityname gaibian leixing: chtype binary_delta_file Estonian.r错误 :clearfsimport: Error: Trouble was encountered importing the following elements: D:\work\shiquan_study\Broadcom070122\BCM_R2.10_A1\mmi\design\gui\res\ffs_preload\CD_5_2_6.dm]]></content>
      <categories>
        <category>软件版本管理</category>
      </categories>
      <tags>
        <tag>clearcase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致橡树]]></title>
    <url>%2F2018%2F05%2F09%2F%E8%87%B4%E6%A9%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近看《极限挑战》第四季，又听到这首诗，想起了还是在上学时候读过的~~~记一下咯。 【作者】舒婷 【朝代】现代 我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
</search>
