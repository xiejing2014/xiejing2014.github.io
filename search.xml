<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Oracle正则表达式函数：regexp_like、regexp_substr、regexp_instr、regexp_replace]]></title>
    <url>%2F2018%2F05%2F25%2FOracle%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Oracle使用正则表达式4个主要函数： 1、regexp_like 只能用于条件表达式，和 like 类似，但是使用的正则表达式进行匹配，语法很简单：2、regexp_substr 函数，和 substr 类似，用于拾取合符正则表达式描述的字符子串，语法如下：3、regexp_instr 函数，和 instr 类似，用于标定符合正则表达式的字符子串的开始位置，语法如下：4、regexp_replace 函数，和 replace 类似，用于替换符合正则表达式的字符串，语法如下： 这里解析一下几个参数的含义： 1、source_char，输入的字符串，可以是列名或者字符串常量、变量。 2、pattern，正则表达式。 3、match_parameter，匹配选项。 取值范围： i：大小写不敏感； c：大小写敏感；n：点号 . 不匹配换行符号；m：多行模式；x：扩展模式，忽略正则表达式中的空白字符。 4、position，标识从第几个字符开始正则表达式匹配。 5、occurrence，标识第几个匹配组。 6、replace_string，替换的字符串。 示例： 基础数据准备1234567891011121314151617181920212223-- 创建表及测试数据create table tmp ( ID varchar2(60), STR varchar2(60))insert into tmp values (&apos;like&apos;,&apos;a9999&apos;);insert into tmp values (&apos;like&apos;,&apos;a9c&apos;);insert into tmp values (&apos;like&apos;,&apos;A7007&apos;);insert into tmp values (&apos;like&apos;,&apos;123a34cc&apos;);insert into tmp values (&apos;substr&apos;,&apos;123,234,345&apos;);insert into tmp values (&apos;substr&apos;,&apos;12,34.56:78&apos;);insert into tmp values (&apos;substr&apos;,&apos;123456789&apos;);insert into tmp values (&apos;instr&apos;,&apos;192.168.0.1&apos;);insert into tmp values (&apos;replace&apos;,&apos;(020)12345678&apos;);insert into tmp values (&apos;replace&apos;,&apos;001517729C28&apos;);-- 查询插入结果SQL&gt; select count(*) from tmp; COUNT(*)---------- 10 regexp_like12345678910111213141516171819202122232425262728293031323334-- regexp_like示例-- &apos;i&apos;忽略大小写SQL&gt; SELECT str from tmp where id=&apos;like&apos; and regexp_like(str,&apos;A\d+&apos;,&apos;i&apos;);STR------------------------------------------------------------a9999a9cA7007123a34cc-- 不带&apos;i&apos;SQL&gt; select str from tmp where id=&apos;like&apos; and regexp_like(str, &apos;a\d+&apos;);STR------------------------------------------------------------a9999a9c123a34cc-- 匹配以a开头的SQL&gt; select str from tmp where id=&apos;like&apos; and regexp_like(str,&apos;^a\d+&apos;);STR------------------------------------------------------------a9999a9c-- 匹配以a开头，以数字结尾的SQL&gt; SELECT str from tmp where id=&apos;like&apos; and regexp_like(str,&apos;^a\d+$&apos;);STR------------------------------------------------------------a9999 regexp_substr123456789-- regexp_substr示例1SELECTstr,regexp_substr(str,&apos;[^,]+&apos;) str_1_1,regexp_substr(str,&apos;[^,]+&apos;,1,1) str_1_1,regexp_substr(str,&apos;[^,]+&apos;,1,2) str_1_2, -- occurrence 第几个匹配组regexp_substr(str,&apos;[^,]+&apos;,2,1) str_2_1 -- position 从第几个字符开始匹配from tmpwhere id=&apos;substr&apos;; 查询结果： 12345678910-- regexp_substr示例2SQL&gt; col str format a20SQL&gt; SELECT 2 STR, 3 REGEXP_SUBSTR(STR, &apos;\d&apos;) STR, 4 REGEXP_SUBSTR(STR, &apos;\d+&apos;, 1, 1) STR, 5 REGEXP_SUBSTR(STR, &apos;\d&#123;2&#125;&apos;, 1, 2) STR, 6 REGEXP_SUBSTR(STR, &apos;\d&#123;3&#125;&apos;, 2, 1) STR 7 FROM TMP 8 WHERE ID = &apos;substr&apos;; 查询结果： regexp_instr 略，以后补充。 regexp_replace123456-- regexp_replace示例SELECT STR,REGEXP_REPLACE(STR, &apos;020&apos;, &apos;GZ&apos;) STR,REGEXP_REPLACE(STR, &apos;(\d&#123;3&#125;)(\d&#123;3&#125;)&apos;, &apos;&lt;\2\1&gt;&apos;) STR -- 将第一、第二捕获组交换位置，用尖括号标识出来FROM TMPWHERE ID = &apos;replace&apos;; 查询结果： 综合示例12345678910111213141516171819-- 建表create table tmp1(id varchar2(60),str varchar2(512));-- 插入测试数据insert into tmp1 values(&apos;test&apos;,&apos;020000080568179234090000010030040050040205090070080040050000060289634175010000020&apos;);-- 使用regex函数处理数据SQL&gt; select str,REGEXP_SUBSTR(str,&apos;\d&#123;9&#125;&apos;) as row_line from tmp1; STR ROW_LINE02000008056817923409 0200000800000010030040050040205090070080040050000060289634-- 未完待续 查询结果： 参考资源：https://www.cnblogs.com/suinlove/p/3981454.html https://docs.oracle.com/database/121/SQLRF/conditions007.htm#SQLRF00501]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>regex</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享1文,30分钟速览Regex正则表达式]]></title>
    <url>%2F2018%2F05%2F23%2F%E5%88%86%E4%BA%AB1%E6%96%87-30%E5%88%86%E9%92%9F%E9%80%9F%E8%A7%88Regex%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最初接触正则表达式是在学习shell的时候，涉及到正则表达式的匹配。后来，正则表达式在各处用得也逐渐开始多了起来。。分享此文，记录一下。 资料参考：http://www.jb51.net/tools/zhengze.html 备注：以后遇到正则相关的内容或者一些开发中的问题，可以往本文添加。]]></content>
      <categories>
        <category>关联知识点</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clearcase常用命令]]></title>
    <url>%2F2018%2F05%2F22%2Fclearcase%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 常规操作1.1 最基本的操作cleartool co -nc xxx.cppcleartool ci -nc xxx.cpp 1.2 查看自己总共co了多少文件cleartool lscheckout -cview -me -avobs 1.3 最有用的命令cleartool man xxxcleartool help xxx 1.4 新增目录和文件cleartool mkdir -c comment new_dircleartool mkelem -c comment new_file.cpp 1.5 放弃co某个文件cleartool unco -keep file.cpp //保留当前所改动的文件cleartool unco -rm file.cpp 1.6 主线、分支文件合并//查找需要合并的文件cleartool findmerge . -fversion /main/xxxx_path -print//比较文件不同cleartool diff file.cpp file.cpp@@/main/xxxx_path/LATEST//查看最新版本cleartool lsvtree file.cpp//合并cleartool merge -to file.cpp file.cpp@@/main/xxxx_path/LATEST file.cpp@@/main/LATEST 1.7 标签相关//新建标签cleartool mklbtype -nc TEST_LABEL//给文件打标签cleartool mklabel -r TEST_LABEL file.cpp//删除标签cleartool rmtype lbtype:TEST_LABEL//给所有打上TEST_LABEL标签的文件打上TEST_LABEL2标签cleartool mklabel -replace -version /main/TEST_LABEL TEST_LABEL2 *//查找打上TEST_LABEL标签的所有文件cleartool find . -version “lbtype(TEST_LABEL)” -print//查找打上TEST_LABEL和TEST_LABEL2标签的文件cleartool find . -element ‘lbtype_sub(TEST_LABEL) &amp;&amp; lbtype_sub(TEST_LABEL2)’ -print 1.8 将整个目录导入clearcaseclearfsimport -recurse /xxx/xxx/xxx/src /view/zhuj/home/vobs/cc_account/xxx/xxx/xxx/src目录（包括此目录下的所有目录和文件）被导入/view/zhuj/home/vobs/cc_account中（/view/zhuj/home/vobs/cc_account/src） 2. clearcase常用命令集锦2.1 将整个目录导入clearcaseclearfsimport -r‘源路径’ ‘目标路径’ 2.2 加锁find . -name ‘.‘ -exec ‘cleartool lock nuser userame1,username2 “%CLEARCASE_PN%”‘ 2.3 解锁find . -name ‘.‘ -exec ‘cleartool unlock “%CLEARCASE_PN%”‘ 2.4 转换格式chtype -f compressed_file “fileName” 2.5 查看VOB的基本信息和UUIDdes -l vob:. 2.6 删除视图rmview -uuid “UUID” 2.7 删除lost+foundfind . -name ‘.‘ -exec ‘cleartool rmelem -f “%CLEARCASE_PN%”‘ 2.8 查询某一天的修改记录cleartool lshis -r -since 07-dec 2.9 最基本的操作cleartool co -nc filenamecleartool ci -nc filename 2.10 查看自己总共co了多少文件cleartool lscheckout -cview –me -vobs 2.11 make目录和文件cleartool mkdir -c comment newdirectorycleartool mkelem -c comment newfilename 2.12 主线、分支文件合并//查找需要合并的文件cleartool findmerge . -fversion /main/TEST_Path -print//比较文件不同cleartool diff filename [url=mailto:file.cpp@@/main/xxxx_path/LATEST]filename@@/main/TEST_Path/LATEST//查看最新版本cleartool lsvtree filename//合并cleartool merge -to filename [url=mailto:file.cpp@@/main/xxxx_path/LATEST]filename @@/main/TEST_path/LATEST [url=mailto:file.cpp@@/main/LATEST]filename @@/main/LATEST 2.13 标签相关cleartool mklbtype -nc TEST_LABELcleartool mklabel -r TEST_LABEL filenamecleartool rmtype lbtype:TEST_LABEL//给所有打上TEST_LABEL标签的文件打上TEST_LABEL标签cleartool mklabel -replace -version /main/TEST_LABEL TEST_LABEL *//查找打上TEST_LABEL标签的所有文件cleartool find . -version “lbtype(TEST_LABEL)” -print//查找打上TEST_LABEL和TEST_LABEL1标签的文件cleartool find . -element ‘lbtype_sub(TEST_LABEL) &amp;&amp; lbtype_sub(TEST_LABEL1)’ -print 2.14 察看某目录下的文件ls 2.15 man/help命令cleartool man xxxcleartool help xxx 2.16 放弃co某个文件cleartool unco -keep filenamecleartool unco -rm filename 2.17 更改VOB的Owner:cleartool protectvob –chown root /vob/vob.vbs 2.18 更改VOB的Group:cleartool protectvob –chgrp alluser /vob/vob.vbs 2.19 增加Additional Group:cleartool protectvob –add_group group1 /vob/vob.vbs 2.20 删除Additional Group:cleartool protectvob –delete_group group1 /vob/vob.vbs 2.21 更改group、owner、modprotect -r -chgrp groupname–chown username -chmod 770 . 2.22 创建VOBcleartool mkvob -tag /vobtags/test_code -c “Test” “D:\Data\Tets.vbs” 2.23 Mount vobCleartool mount /vobtags/vob 2.24 创建视图cleartool mkview –tag test /ccvob/views/test.vws 2.25 设置当前视图cleartool setview test 2.26 设置当前的activitycleartool setactivity activityname 2.27 Check outCheck out一个文件 Cleartool checkout [-reserve][-unreserve] filename Check out前目录 Cleartool checkout . Check out当前目录下所有文件 Cleartool Checkout –nc . Check out当前目录下所有的文件和目录中的文件 cleartool find . $file -exec ‘cleartool checkout -nc $CLEARCASE_PN’ 2.28 Check inCheck in 一个文件 Cleartool checkin filename Check in 当前目录Cleartool checkin . Check in 当前目录下所有文件. Cleartool Checkin –nc . Check in当前目录下所有的文件和目录中的文件 cleartool find . $file -exec ‘cleartool checkin -nc –ide $CLEARCASE_PN’ 以上内容来自：http://hi.baidu.com/is%CC%EC%B2%C5/blog/item/36bfbfc83cced1117f3e6fa0.html 3. 常用命令创建view：clt mkview -tag view_abcd /view_store/view_abcd.vws设置view: clt setview view_abcd编辑config specification: clt edcs 创建branch type：clt mkbrtype dbg_branch1_comments在某个文件的当前branch上， 拉出一个branch：clt mkbranch dbg_branch1_comments filename.c now you have make branch on the file, and checked it out.you can edit it with gvim.After changed codes, you can complie it successfully, and test the result, you can check it in.clt ci filename.cIf you want to check out it again:clt co filename.c To change the branch name to a formula name you can use the command:clt rename brtype:dbg_branch1_comments brtype:crnumber_branch1_comments To see the version tree of a file:clt lsvtree -g filename.c To see which files is included in a branch, you can edit a script like this find_branch.sh: echo “$1”cleartool find -avobs -element “brtype(“$1”)” -nxn -print | xargs cleartool ls -s|grep “$1” To compare files, I write a useful script file mydiff. You can use xcc&amp; to open graphic clearcase. So you can do most thing through the menu. 以上内容来自：http://www.diybl.com/course/4_webprogram/asp.net/netjs/20071020/78573.html 4. clearcase实用命令查找分支上的文件find . -branch brtype(branchname) -print创建分支mkbrtype -c “comment” branchname创建Labelmklbtype -c “comment” labelname用于 cleartool find 查询:cleartool find -all -version “lbtype(REL1)” -printfind . -version ‘lbtype(LABEL)’ -print锁分支命令lock brtype:branchname创建triggertrigger已存在mktrtype mktrtype -replace -element -all -preop mkelem -nusers shiquan -exec http://www.cnblogs.com/samcn/admin/file://192.168.1.5/cc_trigger/false.bat NO_RM_MKtrigger不存在mktrtype mktrtype -element -all -preop mkelem -nusers shiquan -exec http://www.cnblogs.com/samcn/admin/file://192.168.1.5/cc_trigger/false.bat NO_RM_MK日常开发人员常用命令 5. 开发人员常用命令5.1 建立vobmkvob –tag /vobtags/vob1 –c “ VOB for project1” /vobstore/vob1.vbs 5.2 Mount vobCleartool mount /vobtags/vob1 5.3 创建视图cleartool mkview –tag test1 /ccvob/views/test1.vws 5.4 设置当前视图cleartool setview test1 5.5 在VOB的根目录下到入数据：clearfsimport –recurse –c “ comments “ /home/setup/* . ，注意命令的最后为圆点，表示当前目录。 5.6 改变VOB的Owner:cleartool protectvob –chown root /vobstore/vob1.vbs 5.7 改变VOB的Group:cleartool protectvob –chgrp alluser /vobstore/vob1.vbs 5.8 增加Additional Group:cleartool protectvob –add_group group1 /vobstore/vob1.vbs 5.9 删除Additional Group:cleartool protectvob –delete_group group1 /vobstore/vob1.vbs修改vob中数据的权限信息 5.10 将jmccboss VOB 中所有元素Owner 改成ccadmin，Group改成jmccboss:Cleartool protect –chown ccadmin –chgrp jmccboss ..为vob根目录 5.11 将jmccboss VOB 中所有元素权限 改成对ccadmin（rwx），jmccboss(rwx)，其他VOB附属组成员（r-x）:例： Cleartool protect –recurse –chmod 775 . ， 5.12 Mount vobCleartool mount /vobtags/vob1 5.13 创建视图cleartool mkview –tag test1 /ccvob/views/test1.vws 5.14 设置当前视图cleartool setview test1 5.15 在VOB的根目录下到入数据：clearfsimport –recurse –c “ comments “ /home/setup/* . ，注意命令的最后为圆点，表示当前目录。 5.16 Check outCleartool checkout [-reserve][-unreserve] b.c Check out一个文件Cleartool checkout . Check out当前目录Cleartool Checkout –nc . Check out当前目录下所有文件cleartool find . $file -exec ‘cleartool checkout -nc $CLEARCASE_PN’Check out当前目录下所有的文件和目录中的文件 5.17 Check inCleartool checkin b.c Check in 一个文件Cleartool checkin . Check in 当前目录Cleartool Checkin –nc . Check in 当前目录下所有文件.cleartool find . $file -exec ‘cleartool checkin -nc –ide $CLEARCASE_PN’Check in当前目录下所有的文件和目录中的文件 5.18 建立一个snapshot viewcleartool mkview –tag pat_2_snapshot_view –snapshot /viewstore/pat/myviews.vws 5.19 编辑config speCleartool edcs 5.20 更新snapshot viewcleartool update pat_2_snapshot_view 5.21 设置当前的activitycleartool setactivity activityname gaibian leixing: chtype binary_delta_file Estonian.r错误 :clearfsimport: Error: Trouble was encountered importing the following elements: D:\work\shiquan_study\Broadcom070122\BCM_R2.10_A1\mmi\design\gui\res\ffs_preload\CD_5_2_6.dm]]></content>
      <categories>
        <category>软件版本管理</category>
      </categories>
      <tags>
        <tag>clearcase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle某些函数学习记录（2018-05-21备忘）]]></title>
    <url>%2F2018%2F05%2F21%2FOracle%E6%9F%90%E4%BA%9B%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%882018-05-21%E5%A4%87%E5%BF%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近需要了解一下oracle的有关函数，故寻觅一番，总结如下。 更多内容参考Oracle官网。以下参考网络资源学习、摘录总结。 本文使用的本地oracle环境对参考资源进行了学习，当前版本为：12345678910111213141516171819202122232425SQL&gt; select * from v$version;BANNER-------------------------------------------------------------------------------- CON_ID----------Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production 0PL/SQL Release 12.2.0.1.0 - Production 0CORE 12.2.0.1.0 Production 0BANNER-------------------------------------------------------------------------------- CON_ID----------TNS for Linux: Version 12.2.0.1.0 - Production 0NLSRTL Version 12.2.0.1.0 - Production 0 1. DBMS_OBFUSCATION_TOOLKIT.MD5和Utl_Raw.Cast_To_RawDBMS_OBFUSCATION_TOOLKIT.MD5是MD5编码的数据包函数，可以直接在SQL中进行调用。12345SQL&gt; select Utl_Raw.Cast_To_Raw(sys.dbms_obfuscation_toolkit.md5(input_string =&gt; &apos;111&apos;)) from dual;UTL_RAW.CAST_TO_RAW(SYS.DBMS_OBFUSCATION_TOOLKIT.MD5(INPUT_STRING=&gt;&apos;111&apos;))--------------------------------------------------------------------------------698D51A19D8A121CE581499D7B701668 其结果返回的字串为RAW类型，要正确显示的话，需要经过Utl_Raw.Cast_To_Raw转换。关于RAW类型，可详见本文第2节说明。 2. RAW类型oracle中用于保存位串的数据类型是RAW或者LONG RAW。RAW类似于CHAR，声明方式为RAW(L)，L为单位，以字节表示，作为数据库列最大为2000，作为变量最大32767字节。LONG RAW，类似于LONG，作为数据库列最大存储2G字节的数据，作为变量最大32760字节RAW类型的好处就是：在网络中的计算机之间传输 RAW 数据时，或者使用 Oracle 实用程序将 RAW 数据从一个数据库移到另一个数据库时，Oracle服务器不执行字符集转换。存储实际列值所需要的字节数大小随每行大小而异，最多为 2000字节。可能这样的数据类型在数据库效率上会提高，而且对数据由于字符集的不同而导致的不一致的可能性在这边也排除了。RAW保存的为16进制数，对应每个字符的ASCII码。常见的两个函数为utl_raw.cast_to_raw([varchar2]) 和utl_raw.cast_to_varchar2([raw])。如下：123456789101112SQL&gt; select utl_raw.cast_to_raw(&apos;甲骨文&apos;) name from dual;NAME--------------------------------------------------------------------------------E794B2E9AAA8E69687SQL&gt; SQL&gt; select utl_raw.cast_to_varchar2(&apos;E794B2E9AAA8E69687&apos;) name from dual;NAME--------------------------------------------------------------------------------甲骨文 题外话：使用SQL语句时，注意SERVER端和CLIENT端的字符集得一致，否则查询可能中文乱码。SERVER端：12345SQL&gt; select userenv(&apos;language&apos;) from dual;USERENV(&apos;LANGUAGE&apos;)----------------------------------------------------AMERICAN_CHINA.AL32UTF8 CLIENT终端调整为显示一致：(如下临时调整)1export NLS_LANG=&quot;AMERICAN_CHINA.AL32UTF8&quot; 调整之后，对应终端能够正常显示中文。 上述1,2节内容亦可参照以下链接：https://blog.csdn.net/lwei_998/article/details/6070689https://blog.csdn.net/john2522/article/details/8124087(或者https://blog.csdn.net/afzaici/article/details/51669495http://blog.chinaunix.net/uid-90674-id-2436668.html) 3. XMLTYPE操作，学习extract()和extractvalue()3.1 特性概述对于文件等复杂且大体积的数据对象，Oracle通常采用LOB类型的变量来进行存储。对于XML数据文件，Oracle提供了XMLTYPE的数据类型。xmltype提供了适合的保存、检索和操作的支持。以下为一些特性介绍：作为xmltype，Oracle会在数据表上建立一个clob类型的系统列，用于协助保存数据。可参考“xmltype类型浅析”一文：https://www.linuxidc.com/Linux/2017-03/141678.htm对于LOB类型，可参考“Oracle LOB类型介绍”一文：https://blog.csdn.net/bbliutao/article/details/19707169 3.2 XMLTYPE简单操作实例3.2.1 创建test.xml文件文件路径及名称：/home/oracle/xml/test.xmlxml格式文件，文件内容如下：1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;collection xmlns=&quot;&quot;&gt; &lt;record&gt; &lt;leader&gt;-----nam0-22-----^^^450-&lt;/leader&gt; &lt;datafield tag=&quot;200&quot; ind1=&quot;1&quot; ind2=&quot; &quot;&gt; &lt;subfield code=&quot;a&quot;&gt;抗震救灾&lt;/subfield&gt; &lt;subfield code=&quot;f&quot;&gt;奥运会&lt;/subfield&gt; &lt;/datafield&gt; &lt;datafield tag=&quot;209&quot; ind1=&quot; &quot; ind2=&quot; &quot;&gt; &lt;subfield code=&quot;a&quot;&gt;经济学&lt;/subfield&gt; &lt;subfield code=&quot;b&quot;&gt;计算机&lt;/subfield&gt; &lt;subfield code=&quot;c&quot;&gt;10001&lt;/subfield&gt; &lt;subfield code=&quot;d&quot;&gt;2005-07-09&lt;/subfield&gt; &lt;/datafield&gt; &lt;datafield tag=&quot;610&quot; ind1=&quot;0&quot; ind2=&quot; &quot;&gt; &lt;subfield code=&quot;a&quot;&gt;计算机&lt;/subfield&gt; &lt;subfield code=&quot;a&quot;&gt;笔记本&lt;/subfield&gt; &lt;/datafield&gt; &lt;/record&gt;&lt;/collection&gt; 3.2.2 创建存放XML文件的表建表1234567SQL&gt; create table xmlexample( ID varchar2(60), name varchar2(60), data xmltype );Table created. 插入数据123456789101112SQL&gt; create directory XMLPATH_TEST as &apos;/home/oracle/xml&apos;;Directory created.insert into xmlexample(id,name,data)values(sys_guid(),&apos;my document&apos;, xmltype ( bfilename(&apos;XMLPATH_TEST&apos;,&apos;test.xml&apos;), nls_charset_id(&apos;AL32UTF8&apos;) )); 查询插入结果123456789101112131415SQL&gt; select * from xmlexample;ID------------------------------------------------------------NAME------------------------------------------------------------DATA--------------------------------------------------------------------------------6CB32CE193E2D536E055000000000001my document&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;collection xmlns=&quot;&quot;&gt; &lt;record&gt; &lt;leaSQL&gt; 3.2.3 extractvalue()函数的使用Oracle提供对XML文件的检索功能（extractvalue），extractvalue只能返回一个节点的一个值，具体操作方法如下：1234567891011SQL&gt; select id,name,extractvalue(x.data,&apos;/collection/record/leader&apos;) as A from xmlexample x;ID------------------------------------------------------------NAME------------------------------------------------------------A--------------------------------------------------------------------------------6CB32CE193E2D536E055000000000001my document-----nam0-22-----^^^450- 如果该节点有两个值，则系统提示错误。 3.2.4 extract()函数的使用如果想查询所有subfield的值就要用到extract()，它可以返回一个节点下的所有值。操作如下：123456789101112SQL&gt; select id,name, extract(x.data,&apos;/collection/record/datafield/subfield&apos;) as A from xmlexample x;ID------------------------------------------------------------NAME------------------------------------------------------------A--------------------------------------------------------------------------------6CB32CE193E2D536E055000000000001my document&lt;subfield code=&quot;a&quot;&gt;抗震救灾&lt;/subfield&gt;&lt;subfield code=&quot;f&quot;&gt;奥运会&lt;/subfiel 可以看到它返回的是XML格式的。如果我们想只返回它的值就要是用两个函数了。 3.2.5 table和XMLSequence123456789101112131415161718SQL&gt; select extractValue(value(i),&apos;/subfield&apos;) xx 2 from xmlexample x, 3 table(XMLSequence(extract(x.data,&apos;/collection/record/datafield/subfield&apos;))) i;XX--------------------------------------------------------------------------------抗震救灾奥运会经济学计算机100012005-07-09计算机笔记本8 rows selected.SQL&gt; 3.2.6 检索出特定的节点的特定值有时候我们在实际操作的时候并不是检索出所有值，而是根据条件查询出我们所需要的信息。如果我们想检索出12&lt;datafield tag=&quot;209&quot; ind1=&quot; &quot; ind2=&quot; &quot;&gt;&lt;subfield code=&quot;a&quot;&gt;经济学&lt;/subfield&gt; 中的值-经济学操作如下：123456789101112SQL&gt; select id,name,extractvalue(x.data,&apos;/collection/record/datafield[@tag=&quot;209&quot;]/subfield[@code=&quot;a&quot;]&apos;) as A 2 from xmlexample x;ID------------------------------------------------------------NAME------------------------------------------------------------A--------------------------------------------------------------------------------6CB32CE193E2D536E055000000000001my document经济学 3.2.7 XMLTYPE小结Oracle对于XMLType的操作有很多种，还要靠大家自己去发现。数据库对XML的检索就是把XML的节点当作一个列来检索，而不同的是表里装的是二维的数据，而XML中可以装N维。还有就是，表中列不存在就会提示无效标识符，如果节点不存在，则检索出NULL，不会报错。所以，对与XML文件的操作通常是通过视图来完成。 以上学习内容参照：https://www.cnblogs.com/millen/archive/2011/12/28/2304410.html关于Oracle中XML函数的接口介绍，可参见下文：http://huangronaldo.iteye.com/blog/1457567 4. dbms_job用法dbms_job，用于安排和管理作业队列，通过作业控制，使oracle数据库定期执行特定的任务。 4.1 dbms_job涉及到的知识点1、创建jobvariable jobno number;dbms_job.submit(:jobno, —-job号 ‘your_procedure;’,—-执行的存储过程, ‘;’不能省略 next_date, —-下次执行时间 ‘interval’ —-每次间隔时间，interval以天为单位);–- 系统会自动分配一个任务号jobno。 2、删除job: dbms_job.remove(jobno); 3、修改要执行的操作: job:dbms_job.what(jobno, what); 4、修改下次执行时间：dbms_job.next_date(jobno, next_date); 5、修改间隔时间：dbms_job.interval(jobno, interval); 6、启动job: dbms_job.run(jobno); 7、停止job: dbms.broken(jobno, broken, nextdate); –broken为boolean值 4.2 初始化相关参数job_queue_processes1、job_queue_process表示oracle能够并发的job的数量，当job_queue_process值为0时表示全部停止oracle的job。 2、查看job_queue_processes参数方法一：show parameter job_queue_process;方法二：select * from v$parameter where name=’job_queue_processes’; 3、修改job_queue_processes参数（感觉非必须，初始应该有合理值，mark察其用法 by xj）alter system set job_queue_processes = 10; 4.3 user_jobs表结构字段（列） 类型 描述job number 任务的唯一标示号log_user varchar2(30) 提交任务的用户priv_user varchar2(30) 赋予任务权限的用户schema_user varchar2(30) 对任务作语法分析的用户模式last_date date 最后一次成功运行任务的时间last_sec varchar2(8) 如hh24:mm:ss格式的last_date日期的小时，分钟和秒this_date date 正在运行任务的开始时间，如果没有运行任务则为nullthis_sec varchar2(8) 如hh24:mm:ss格式的this_date日期的小时，分钟和秒next_date date 下一次定时运行任务的时间 4.4 一个dbms_job使用的具体案例4.4.1 在plsql中创建表123456create table tt( id varchar2(30), name varchar2(30));Table created. 4.4.2 在plsql中创建存储过程12345678create or replace procedure proce_t isbegin insert into tt(id, name) values(&apos;1&apos;, to_char(sysdate, &apos;yyyy-mm-dd hh24:mi:ss&apos;)); commit;end proce_t;/Procedure created. 4.4.3 创建job任务(1分钟执行一次)12345678variable jobno number;begin dbms_job.submit(:jobno,&apos;proce_t;&apos;, sysdate, &apos;sysdate+1/24/60&apos;); commit;end;/PL/SQL procedure successfully completed. 4.4.4 跟踪任务的情况(查看任务队列)1234567SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs; JOB NEXT_DATE NEXT_SEC FAILURES B---------- ------------------ -------------------------------- ---------- - 1 21-MAY-18 00:26:45 0 NSQL&gt; 查看定时任务执行情况。1234567SQL&gt; select * from tt;ID NAME------------------------------ ------------------------------1 2018-05-21 00:25:451 2018-05-21 00:26:501 2018-05-21 00:27:55 4.4.5 停止定时任务4.4.5.1 查看定时任务的job号1234567SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs; JOB NEXT_DATE NEXT_SEC FAILURES B---------- ------------------ -------------------------------- ---------- - 1 21-MAY-18 00:30:00 0 NSQL&gt; 4.4.5.2 停止一个已启动的定时任务123456begin dbms_job.broken(1, true, sysdate); commit;end;/PL/SQL procedure successfully completed. 4.4.5.3 查看定时任务是否已停止成功1234567SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs; JOB NEXT_DATE NEXT_SEC FAILURES B---------- ------------------ -------------------------------- ---------- - 1 01-JAN-00 00:00:00 0 YSQL&gt; broken值为y，表示定时任务已停止。 4.4.6 启动定时任务4.4.6.1 查看停止定时任务1234567SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs; JOB NEXT_DATE NEXT_SEC FAILURES B---------- ------------------ -------------------------------- ---------- - 1 01-JAN-00 00:00:00 0 YSQL&gt; broken值为y，表示定时任务已停止。 4.4.6.2 启动定时任务123456begin dbms_job.run(1); commit;end;/PL/SQL procedure successfully completed. 4.4.6.3 查看定时任务是否已启动1234567SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs; JOB NEXT_DATE NEXT_SEC FAILURES B---------- ------------------ -------------------------------- ---------- - 1 21-MAY-18 00:34:40 0 NSQL&gt; broken值为n，表示定时任务启动成功。 4.4.7 查看进程数123456SQL&gt; show parameter job_queue_processes;NAME TYPE VALUE------------------------------------ ----------- ------------------------------job_queue_processes integer 4000SQL&gt; 必须大于0，否则执行下面的命令修改：1alter system set job_queue_processes=10; 4.4.8 再创建一个任务(每5分钟执行一次)创建123456variable jobno number;begin dbms_job.submit(:jobno, &apos;proce_t;&apos;, sysdate, &apos;sysdate+1/24/12&apos;); --interval是以天为单位的 commit;end;/ 执行12345678SQL&gt; select job,next_date,next_sec,failures,broken from user_jobs; JOB NEXT_DATE NEXT_SEC FAILURES B---------- ------------------ -------------------------------- ---------- - 1 21-MAY-18 00:36:50 0 N 2 21-MAY-18 00:41:25 0 NSQL&gt; 4.5 job运行时间的总结1:每分钟执行Interval =&gt; TRUNC(sysdate,’mi’) + 1/(2460)2:每天定时执行例如：每天的凌晨1点执行Interval =&gt; TRUNC(sysdate) + 1 +1/(24)3:每周定时执行例如：每周一凌晨1点执行Interval =&gt; TRUNC(next_day(sysdate,’星期一’))+1/244:每月定时执行例如：每月1日凌晨1点执行Interval =&gt;TRUNC(LAST_DAY(SYSDATE))+1+1/245:每季度定时执行例如每季度的第一天凌晨1点执行Interval =&gt; TRUNC(ADD_MONTHS(SYSDATE,3),’Q’) + 1/246:每半年定时执行例如：每年7月1日和1月1日凌晨1点Interval =&gt; ADD_MONTHS(trunc(sysdate,’yyyy’),6)+1/247:每年定时执行例如：每年1月1日凌晨1点执行Interval =&gt;ADD_MONTHS(trunc(sysdate,’yyyy’), 12)+1/24job的运行频率设置1.每天固定时间运行，比如早上8:10分钟：Trunc(Sysdate+1) + (860+10)/24602.Toad中提供的：每天：trunc(sysdate+1)每周：trunc(sysdate+7)每月：trunc(sysdate+30)每个星期日：next_day(trunc(sysdate),’星期日’)每天6点：trunc(sysdate+1)+6/24半个小时：sysdate+30/(2460)3.每个小时的第15分钟运行，比如：8:15，9:15，10:15…：trunc(sysdate,’hh’)+(60+15)/(24*60) 。 上文参见：oracle数据库定时任务dbms_job的用法详解http://www.jb51.net/article/92575.htm 更多详情可参见以下两篇文章，有关于CHANGE的介绍。 更多dbms_job包的说明：http://wallimn.iteye.com/blog/519924 PS:change实际就是改变当前某个job设置的工作参数，包括job、what、next_date和interval参数。job参数是一个整数值，它唯一标识此工作。what参数是由此工作运行的一块PL/SQL代码块。next_date参数指示何时此工作将被执行。interval参数指示一个工作重执行的频度。 关于一些参数的解释可以参照一下：https://www.cnblogs.com/chenjunjie/p/5054415.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用不同语言来遍历目录和文件]]></title>
    <url>%2F2018%2F05%2F18%2F%E7%94%A8%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E6%9D%A5%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近翻移动硬盘，发现自己还短暂的写过两个月的perl语言，盘中赫然躺着一些perl脚本，其中一个便是实现的遍历目录及其包含的文件的脚本。该功能无非就是利用递归来写代码，这里想用perl、python、shell和C语言分别对其进行编写，聊发少年狂而已。 1、程序列表12345678[root@localhost script]# ls -tlrtotal 28-rwxr--r--. 1 root root 276 May 17 19:16 shell_find.sh-rwxr--r--. 1 root root 444 May 17 19:17 python_find.py-rwxr--r--. 1 root root 782 May 17 19:18 perl_find.sh-rw-r--r--. 1 root root 1184 May 17 19:36 C_Find.c-rwxr-xr-x. 1 root root 9048 May 17 19:37 C_Find[root@localhost script]# 1.1 perl123456789101112131415161718192021222324252627282930313233#! /usr/bin/perluse strict;my @filelist;my $dir = &quot;../python&quot;;push(@filelist,&amp;findfile($dir));print join(&quot;\n&quot;,@filelist);print &quot;\n&quot;;sub findfile&#123; my @filelist; my $dir = $_[0]; opendir(DIR,$dir); my @temp = grep(!/^\.\.?$/,readdir(DIR)); close(DIR); my $count = @temp; my $i; my $tmpdir; for($i = 0; $i &lt; $count; $i++)&#123; $tmpdir = (); $tmpdir = &quot;$dir/$temp[$i]&quot;; if(-d &quot;$tmpdir&quot;)&#123; push(@filelist,$tmpdir); push(@filelist,&amp;findfile(&quot;$tmpdir&quot;)); &#125; else &#123; push(@filelist,$tmpdir); &#125; &#125; return @filelist; &#125; 1.2 python123456789101112131415161718#! /usr/bin/python3# coding=utf-8import osbasedir = &apos;../python&apos;filelists = []def find(basedir): global filelists for parent,dirnames,filenames in os.walk(basedir): for dirname in dirnames: filelists.append(os.path.join(parent,dirname)) for filename in filenames: filelists.append(os.path.join(parent,filename))if __name__ == &apos;__main__&apos;: find(basedir) print(&apos;\n&apos;.join(filelists)) 1.3 shell12345678910111213141516171819#! /usr/bin/bashset -o nounsetset -o errexitfunction find()&#123; for file in `ls $1` do if [ -d $1&quot;/&quot;$file ] then echo $1&quot;/&quot;$file find $1&quot;/&quot;$file else echo $1&quot;/&quot;$file fi done&#125;find &quot;../python&quot; 1.4 C源代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* list dir and files through C */ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#define MAX_PATH_LENGTH 512 int find(char *path)&#123; DIR *ptr_dir; struct dirent *dir_entry; int i = 0; char *child_path; child_path = (char*)malloc(sizeof(char)*MAX_PATH_LENGTH); if(child_path == NULL)&#123; printf(&quot;malloc child_path occurs errors.\n&quot;); exit(1); &#125; memset(child_path,0x0,sizeof(char)*MAX_PATH_LENGTH); ptr_dir = opendir(path); while(( dir_entry = readdir(ptr_dir) ) != NULL)&#123; if(dir_entry-&gt;d_type &amp; DT_DIR)&#123; if(strcmp(dir_entry-&gt;d_name,&quot;.&quot;) == 0 || strcmp(dir_entry-&gt;d_name,&quot;..&quot;) == 0)&#123; continue; &#125; sprintf(child_path,&quot;%s/%s&quot;,path,dir_entry-&gt;d_name); printf(&quot;%s\n&quot;,child_path); find(child_path); &#125; else &#123; printf(&quot;%s/%s\n&quot;,path,dir_entry-&gt;d_name); &#125; &#125; free(child_path); child_path = NULL; return 0;&#125;int main()&#123; find(&quot;../python&quot;); return 0;&#125; 编译：1gcc -o C_Find C_Find.c 2、执行结果上述代码执行结果一致，输出文件列表的默认排序或有差别。以shell脚本的执行结果为例，输出如下：123456789101112131415161718192021222324252627[root@localhost script]# ./shell_find.sh ../python/countCodeLine2.py../python/countCodeLine.py../python/countCodeLine.py_ori../python/Django../python/How_to_be_pythonic../python/How_to_be_pythonic/add.c../python/How_to_be_pythonic/adder.so../python/How_to_be_pythonic/app_decrator.py../python/How_to_be_pythonic/cpython_api.py../python/How_to_be_pythonic/cpython_ctype.py../python/How_to_be_pythonic/cpython_SWIG.py../python/How_to_be_pythonic/debug.txt../python/How_to_be_pythonic/decrator.py../python/How_to_be_pythonic/def__.py../python/How_to_be_pythonic/enumerate.py../python/How_to_be_pythonic/exception.py../python/How_to_be_pythonic/forelse.py../python/How_to_be_pythonic/funccode1.py../python/How_to_be_pythonic/Generators.py../python/How_to_be_pythonic/kw-args.py../python/How_to_be_pythonic/out.log../python/How_to_be_pythonic/pprint.py../python/How_to_be_pythonic/set.py../python/How_to_be_pythonic/test3.py../python/How_to_be_pythonic/test.py[root@localhost script]# 3、后记 C语言的实现方法中，有关dirent、stat等结构体含义的描述，可参见： http://www.360doc.com/content/15/0701/10/5470123_481878714.shtml 代码中输出的是目录及文件，可调整。 对列出的文件可做进一步的条件筛选，如后缀判断等。 可比较时间，可优化。 本文原作者:不出名的刀客，转载请一同转发本文链接。 第一次网上写技术文，文有不对之处，欢迎指正。 另，小白正在学习python，欢迎大神留言指教。]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>perl</tag>
        <tag>python</tag>
        <tag>shell</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
