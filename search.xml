<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用不同语言来遍历目录和文件]]></title>
    <url>%2F2018%2F05%2F18%2F%E7%94%A8%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E6%9D%A5%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近翻移动硬盘，发现自己还短暂的写过两个月的perl语言，盘中赫然躺着一些perl脚本，其中一个便是实现的遍历目录及其包含的文件的脚本。 该功能无非就是利用递归来写代码，这里想用perl、python、shell和C语言分别对其进行编写，聊发少年狂而已。 1、程序列表12345678[root@localhost script]# ls -tlrtotal 28-rwxr--r--. 1 root root 276 May 17 19:16 shell_find.sh-rwxr--r--. 1 root root 444 May 17 19:17 python_find.py-rwxr--r--. 1 root root 782 May 17 19:18 perl_find.sh-rw-r--r--. 1 root root 1184 May 17 19:36 C_Find.c-rwxr-xr-x. 1 root root 9048 May 17 19:37 C_Find[root@localhost script]# 1.1 perl123456789101112131415161718192021222324252627282930313233#! /usr/bin/perluse strict;my @filelist;my $dir = &quot;../python&quot;;push(@filelist,&amp;findfile($dir));print join(&quot;\n&quot;,@filelist);print &quot;\n&quot;;sub findfile&#123; my @filelist; my $dir = $_[0]; opendir(DIR,$dir); my @temp = grep(!/^\.\.?$/,readdir(DIR)); close(DIR); my $count = @temp; my $i; my $tmpdir; for($i = 0; $i &lt; $count; $i++)&#123; $tmpdir = (); $tmpdir = &quot;$dir/$temp[$i]&quot;; if(-d &quot;$tmpdir&quot;)&#123; push(@filelist,$tmpdir); push(@filelist,&amp;findfile(&quot;$tmpdir&quot;)); &#125; else &#123; push(@filelist,$tmpdir); &#125; &#125; return @filelist; &#125; 1.2 python123456789101112131415161718#! /usr/bin/python3# coding=utf-8import osbasedir = &apos;../python&apos;filelists = []def find(basedir): global filelists for parent,dirnames,filenames in os.walk(basedir): for dirname in dirnames: filelists.append(os.path.join(parent,dirname)) for filename in filenames: filelists.append(os.path.join(parent,filename))if __name__ == &apos;__main__&apos;: find(basedir) print(&apos;\n&apos;.join(filelists)) 1.3 shell12345678910111213141516171819#! /usr/bin/bashset -o nounsetset -o errexitfunction find()&#123; for file in `ls $1` do if [ -d $1&quot;/&quot;$file ] then echo $1&quot;/&quot;$file find $1&quot;/&quot;$file else echo $1&quot;/&quot;$file fi done&#125;find &quot;../python&quot; 1.4 C源代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* list dir and files through C */ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#define MAX_PATH_LENGTH 512 int find(char *path)&#123; DIR *ptr_dir; struct dirent *dir_entry; int i = 0; char *child_path; child_path = (char*)malloc(sizeof(char)*MAX_PATH_LENGTH); if(child_path == NULL)&#123; printf(&quot;malloc child_path occurs errors.\n&quot;); exit(1); &#125; memset(child_path,0x0,sizeof(char)*MAX_PATH_LENGTH); ptr_dir = opendir(path); while(( dir_entry = readdir(ptr_dir) ) != NULL)&#123; if(dir_entry-&gt;d_type &amp; DT_DIR)&#123; if(strcmp(dir_entry-&gt;d_name,&quot;.&quot;) == 0 || strcmp(dir_entry-&gt;d_name,&quot;..&quot;) == 0)&#123; continue; &#125; sprintf(child_path,&quot;%s/%s&quot;,path,dir_entry-&gt;d_name); printf(&quot;%s\n&quot;,child_path); find(child_path); &#125; else &#123; printf(&quot;%s/%s\n&quot;,path,dir_entry-&gt;d_name); &#125; &#125; free(child_path); child_path = NULL; return 0;&#125;int main()&#123; find(&quot;../python&quot;); return 0;&#125; 编译：1gcc -o C_Find C_Find.c 2、执行结果上述代码执行结果一致，输出文件列表的默认排序或有差别。以shell脚本的执行结果为例，输出如下：123456789101112131415161718192021222324252627[root@localhost script]# ./shell_find.sh ../python/countCodeLine2.py../python/countCodeLine.py../python/countCodeLine.py_ori../python/Django../python/How_to_be_pythonic../python/How_to_be_pythonic/add.c../python/How_to_be_pythonic/adder.so../python/How_to_be_pythonic/app_decrator.py../python/How_to_be_pythonic/cpython_api.py../python/How_to_be_pythonic/cpython_ctype.py../python/How_to_be_pythonic/cpython_SWIG.py../python/How_to_be_pythonic/debug.txt../python/How_to_be_pythonic/decrator.py../python/How_to_be_pythonic/def__.py../python/How_to_be_pythonic/enumerate.py../python/How_to_be_pythonic/exception.py../python/How_to_be_pythonic/forelse.py../python/How_to_be_pythonic/funccode1.py../python/How_to_be_pythonic/Generators.py../python/How_to_be_pythonic/kw-args.py../python/How_to_be_pythonic/out.log../python/How_to_be_pythonic/pprint.py../python/How_to_be_pythonic/set.py../python/How_to_be_pythonic/test3.py../python/How_to_be_pythonic/test.py[root@localhost script]# 3、后记 C语言的实现方法中，有关dirent、stat等结构体含义的描述，可参见： http://www.360doc.com/content/15/0701/10/5470123_481878714.shtml 代码中输出的是目录及文件，可调整。 对列出的文件可做进一步的条件筛选，如后缀判断等。 可比较时间，可优化。 本文原作者:不出名的刀客，转载请一同转发本文链接。 第一次网上写技术文，文有不对之处，欢迎指正。 另，小白正在学习python，欢迎大神留言指教。]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>perl</tag>
        <tag>python</tag>
        <tag>shell</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
