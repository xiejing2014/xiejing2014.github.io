<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莫失莫忘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiejing2014.github.io/"/>
  <updated>2018-05-21T17:11:16.183Z</updated>
  <id>http://xiejing2014.github.io/</id>
  
  <author>
    <name>不出名的刀客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Oracle某些函数学习记录（2018-05-21备忘）</title>
    <link href="http://xiejing2014.github.io/2018/05/21/Oracle%E6%9F%90%E4%BA%9B%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%882018-05-21%E5%A4%87%E5%BF%98%EF%BC%89/"/>
    <id>http://xiejing2014.github.io/2018/05/21/Oracle某些函数学习记录（2018-05-21备忘）/</id>
    <published>2018-05-21T10:09:01.000Z</published>
    <updated>2018-05-21T17:11:16.183Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/oracle_12c.jpg" alt="oracle12c"></p><a id="more"></a><p>最近需要了解一下oracle的有关函数，故寻觅一番，总结如下。</p><p>更多内容参考Oracle官网。<br>以下参考网络资源学习、摘录总结。</p><p>本文使用的本地oracle环境对参考资源进行了学习，当前版本为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from v$version;</span><br><span class="line"></span><br><span class="line">BANNER</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">    CON_ID</span><br><span class="line">----------</span><br><span class="line">Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production</span><br><span class="line">         0</span><br><span class="line"></span><br><span class="line">PL/SQL Release 12.2.0.1.0 - Production</span><br><span class="line">         0</span><br><span class="line"></span><br><span class="line">CORE    12.2.0.1.0      Production</span><br><span class="line">         0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BANNER</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">    CON_ID</span><br><span class="line">----------</span><br><span class="line">TNS for Linux: Version 12.2.0.1.0 - Production</span><br><span class="line">         0</span><br><span class="line"></span><br><span class="line">NLSRTL Version 12.2.0.1.0 - Production</span><br><span class="line">         0</span><br></pre></td></tr></table></figure></p><h1 id="1-DBMS-OBFUSCATION-TOOLKIT-MD5和Utl-Raw-Cast-To-Raw"><a href="#1-DBMS-OBFUSCATION-TOOLKIT-MD5和Utl-Raw-Cast-To-Raw" class="headerlink" title="1. DBMS_OBFUSCATION_TOOLKIT.MD5和Utl_Raw.Cast_To_Raw"></a>1. DBMS_OBFUSCATION_TOOLKIT.MD5和Utl_Raw.Cast_To_Raw</h1><p>DBMS_OBFUSCATION_TOOLKIT.MD5是MD5编码的数据包函数，可以直接在SQL中进行调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select Utl_Raw.Cast_To_Raw(sys.dbms_obfuscation_toolkit.md5(input_string =&gt; &apos;111&apos;)) from dual;</span><br><span class="line"></span><br><span class="line">UTL_RAW.CAST_TO_RAW(SYS.DBMS_OBFUSCATION_TOOLKIT.MD5(INPUT_STRING=&gt;&apos;111&apos;))</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">698D51A19D8A121CE581499D7B701668</span><br></pre></td></tr></table></figure></p><p>其结果返回的字串为RAW类型，要正确显示的话，需要经过Utl_Raw.Cast_To_Raw转换。<br>关于RAW类型，可详见本文第2节说明。</p><h1 id="2-RAW类型"><a href="#2-RAW类型" class="headerlink" title="2. RAW类型"></a>2. RAW类型</h1><p>oracle中用于保存位串的数据类型是RAW或者LONG RAW。<br>RAW类似于CHAR，声明方式为RAW(L)，L为单位，以字节表示，作为数据库列最大为2000，作为变量最大32767字节。<br>LONG RAW，类似于LONG，作为数据库列最大存储2G字节的数据，作为变量最大32760字节<br>RAW类型的好处就是：在网络中的计算机之间传输 RAW 数据时，或者使用 Oracle 实用程序将 RAW 数据从一个数据库移到另一个数据库时，Oracle服务器不执行字符集转换。存储实际列值所需要的字节数大小随每行大小而异，最多为 2000字节。可能这样的数据类型在数据库效率上会提高，而且对数据由于字符集的不同而导致的不一致的可能性在这边也排除了。<br>RAW保存的为16进制数，对应每个字符的ASCII码。常见的两个函数为utl_raw.cast_to_raw([varchar2]) 和utl_raw.cast_to_varchar2([raw])。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select utl_raw.cast_to_raw(&apos;甲骨文&apos;) name from dual;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">E794B2E9AAA8E69687</span><br><span class="line"></span><br><span class="line">SQL&gt; </span><br><span class="line">SQL&gt; select utl_raw.cast_to_varchar2(&apos;E794B2E9AAA8E69687&apos;) name  from dual;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">甲骨文</span><br></pre></td></tr></table></figure></p><p>题外话：使用SQL语句时，注意SERVER端和CLIENT端的字符集得一致，否则查询可能中文乱码。<br>SERVER端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select userenv(&apos;language&apos;) from dual;</span><br><span class="line"></span><br><span class="line">USERENV(&apos;LANGUAGE&apos;)</span><br><span class="line">----------------------------------------------------</span><br><span class="line">AMERICAN_CHINA.AL32UTF8</span><br></pre></td></tr></table></figure></p><p>CLIENT终端调整为显示一致：(如下临时调整)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NLS_LANG=&quot;AMERICAN_CHINA.AL32UTF8&quot;</span><br></pre></td></tr></table></figure></p><p>调整之后，对应终端能够正常显示中文。</p><p><strong><em>上述1,2节内容亦可参照以下链接：</em></strong><br><a href="https://blog.csdn.net/lwei_998/article/details/6070689" target="_blank" rel="noopener">https://blog.csdn.net/lwei_998/article/details/6070689</a><br><a href="https://blog.csdn.net/john2522/article/details/8124087" target="_blank" rel="noopener">https://blog.csdn.net/john2522/article/details/8124087</a><br>(或者<a href="https://blog.csdn.net/afzaici/article/details/51669495" target="_blank" rel="noopener">https://blog.csdn.net/afzaici/article/details/51669495</a><br><a href="http://blog.chinaunix.net/uid-90674-id-2436668.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-90674-id-2436668.html</a><br>)</p><h1 id="3-XMLTYPE操作，学习extract-和extractvalue"><a href="#3-XMLTYPE操作，学习extract-和extractvalue" class="headerlink" title="3. XMLTYPE操作，学习extract()和extractvalue()"></a>3. XMLTYPE操作，学习extract()和extractvalue()</h1><h2 id="3-1-特性概述"><a href="#3-1-特性概述" class="headerlink" title="3.1 特性概述"></a>3.1 特性概述</h2><p>对于文件等复杂且大体积的数据对象，Oracle通常采用LOB类型的变量来进行存储。对于XML数据文件，Oracle提供了XMLTYPE的数据类型。xmltype提供了适合的保存、检索和操作的支持。以下为一些特性介绍：<br>作为xmltype，Oracle会在数据表上建立一个clob类型的系统列，用于协助保存数据。<br><strong><em>可参考“xmltype类型浅析”一文：</em></strong><br><a href="https://www.linuxidc.com/Linux/2017-03/141678.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-03/141678.htm</a><br><strong><em>对于LOB类型，可参考“Oracle LOB类型介绍”一文：</em></strong><br><a href="https://blog.csdn.net/bbliutao/article/details/19707169" target="_blank" rel="noopener">https://blog.csdn.net/bbliutao/article/details/19707169</a></p><h2 id="3-2-XMLTYPE简单操作实例"><a href="#3-2-XMLTYPE简单操作实例" class="headerlink" title="3.2 XMLTYPE简单操作实例"></a>3.2 XMLTYPE简单操作实例</h2><h3 id="3-2-1-创建test-xml文件"><a href="#3-2-1-创建test-xml文件" class="headerlink" title="3.2.1 创建test.xml文件"></a>3.2.1 创建test.xml文件</h3><p>文件路径及名称：/home/oracle/xml/test.xml<br>xml格式文件，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;collection xmlns=&quot;&quot;&gt;</span><br><span class="line">  &lt;record&gt;</span><br><span class="line">    &lt;leader&gt;-----nam0-22-----^^^450-&lt;/leader&gt;</span><br><span class="line">    &lt;datafield tag=&quot;200&quot; ind1=&quot;1&quot; ind2=&quot; &quot;&gt;</span><br><span class="line">      &lt;subfield code=&quot;a&quot;&gt;抗震救灾&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;f&quot;&gt;奥运会&lt;/subfield&gt;</span><br><span class="line">    &lt;/datafield&gt;</span><br><span class="line">    &lt;datafield tag=&quot;209&quot; ind1=&quot; &quot; ind2=&quot; &quot;&gt;</span><br><span class="line">      &lt;subfield code=&quot;a&quot;&gt;经济学&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;b&quot;&gt;计算机&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;c&quot;&gt;10001&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;d&quot;&gt;2005-07-09&lt;/subfield&gt;</span><br><span class="line">    &lt;/datafield&gt;</span><br><span class="line">    &lt;datafield tag=&quot;610&quot; ind1=&quot;0&quot; ind2=&quot; &quot;&gt;</span><br><span class="line">       &lt;subfield code=&quot;a&quot;&gt;计算机&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;a&quot;&gt;笔记本&lt;/subfield&gt;</span><br><span class="line">    &lt;/datafield&gt;</span><br><span class="line">  &lt;/record&gt;</span><br><span class="line">&lt;/collection&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-2-创建存放XML文件的表"><a href="#3-2-2-创建存放XML文件的表" class="headerlink" title="3.2.2 创建存放XML文件的表"></a>3.2.2 创建存放XML文件的表</h3><p><strong>建表</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create table xmlexample(</span><br><span class="line">    ID varchar2(60),</span><br><span class="line">    name varchar2(60),</span><br><span class="line">    data xmltype   </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">Table created.</span><br></pre></td></tr></table></figure></p><p><strong>插入数据</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create directory XMLPATH_TEST as &apos;/home/oracle/xml&apos;;</span><br><span class="line"></span><br><span class="line">Directory created.</span><br><span class="line"></span><br><span class="line">insert into xmlexample(id,name,data)</span><br><span class="line">values(sys_guid(),&apos;my document&apos;,</span><br><span class="line">        xmltype</span><br><span class="line">        (</span><br><span class="line">         bfilename(&apos;XMLPATH_TEST&apos;,&apos;test.xml&apos;),</span><br><span class="line">         nls_charset_id(&apos;AL32UTF8&apos;)</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>查询插入结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from xmlexample;</span><br><span class="line"></span><br><span class="line">ID</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">NAME</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">DATA</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">6CB32CE193E2D536E055000000000001</span><br><span class="line">my document</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;collection xmlns=&quot;&quot;&gt;</span><br><span class="line">  &lt;record&gt;</span><br><span class="line">    &lt;lea</span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-3-extractvalue-函数的使用"><a href="#3-2-3-extractvalue-函数的使用" class="headerlink" title="3.2.3 extractvalue()函数的使用"></a>3.2.3 extractvalue()函数的使用</h3><p>Oracle提供对XML文件的检索功能（extractvalue），extractvalue只能返回一个节点的一个值，具体操作方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select id,name,extractvalue(x.data,&apos;/collection/record/leader&apos;) as A from xmlexample x;</span><br><span class="line"></span><br><span class="line">ID</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">NAME</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">A</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">6CB32CE193E2D536E055000000000001</span><br><span class="line">my document</span><br><span class="line">-----nam0-22-----^^^450-</span><br></pre></td></tr></table></figure></p><p>如果该节点有两个值，则系统提示错误。</p><h3 id="3-2-4-extract-函数的使用"><a href="#3-2-4-extract-函数的使用" class="headerlink" title="3.2.4 extract()函数的使用"></a>3.2.4 extract()函数的使用</h3><p>如果想查询所有subfield的值就要用到extract()，它可以返回一个节点下的所有值。操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select id,name, extract(x.data,&apos;/collection/record/datafield/subfield&apos;) as A from xmlexample x;</span><br><span class="line"></span><br><span class="line">ID</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">NAME</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">A</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">6CB32CE193E2D536E055000000000001</span><br><span class="line">my document</span><br><span class="line">&lt;subfield code=&quot;a&quot;&gt;抗震救灾&lt;/subfield&gt;</span><br><span class="line">&lt;subfield code=&quot;f&quot;&gt;奥运会&lt;/subfiel</span><br></pre></td></tr></table></figure></p><p>可以看到它返回的是XML格式的。如果我们想只返回它的值就要是用两个函数了。</p><h3 id="3-2-5-table和XMLSequence"><a href="#3-2-5-table和XMLSequence" class="headerlink" title="3.2.5 table和XMLSequence"></a>3.2.5 table和XMLSequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select extractValue(value(i),&apos;/subfield&apos;) xx </span><br><span class="line">  2   from xmlexample x,</span><br><span class="line">  3   table(XMLSequence(extract(x.data,&apos;/collection/record/datafield/subfield&apos;))) i;</span><br><span class="line"></span><br><span class="line">XX</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">抗震救灾</span><br><span class="line">奥运会</span><br><span class="line">经济学</span><br><span class="line">计算机</span><br><span class="line">10001</span><br><span class="line">2005-07-09</span><br><span class="line">计算机</span><br><span class="line">笔记本</span><br><span class="line"></span><br><span class="line">8 rows selected.</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-6-检索出特定的节点的特定值"><a href="#3-2-6-检索出特定的节点的特定值" class="headerlink" title="3.2.6 检索出特定的节点的特定值"></a>3.2.6 检索出特定的节点的特定值</h3><p>有时候我们在实际操作的时候并不是检索出所有值，而是根据条件查询出我们所需要的信息。如果我们想检索出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;datafield tag=&quot;209&quot; ind1=&quot; &quot; ind2=&quot; &quot;&gt;</span><br><span class="line">&lt;subfield code=&quot;a&quot;&gt;经济学&lt;/subfield&gt;</span><br></pre></td></tr></table></figure></p><p>中的值-经济学<br>操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select id,name,extractvalue(x.data,&apos;/collection/record/datafield[@tag=&quot;209&quot;]/subfield[@code=&quot;a&quot;]&apos;) as A </span><br><span class="line">  2  from xmlexample x;</span><br><span class="line"></span><br><span class="line">ID</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">NAME</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">A</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">6CB32CE193E2D536E055000000000001</span><br><span class="line">my document</span><br><span class="line">经济学</span><br></pre></td></tr></table></figure></p><h3 id="3-2-7-XMLTYPE小结"><a href="#3-2-7-XMLTYPE小结" class="headerlink" title="3.2.7 XMLTYPE小结"></a>3.2.7 XMLTYPE小结</h3><p>Oracle对于XMLType的操作有很多种，还要靠大家自己去发现。数据库对XML的检索就是把XML的节点当作一个列来检索，而不同的是表里装的是二维的数据，而XML中可以装N维。还有就是，表中列不存在就会提示无效标识符，如果节点不存在，则检索出NULL，不会报错。所以，对与XML文件的操作通常是通过视图来完成。</p><p>以上学习内容参照：<a href="https://www.cnblogs.com/millen/archive/2011/12/28/2304410.html" target="_blank" rel="noopener">https://www.cnblogs.com/millen/archive/2011/12/28/2304410.html</a><br>关于Oracle中XML函数的接口介绍，可参见下文：<br><a href="http://huangronaldo.iteye.com/blog/1457567" target="_blank" rel="noopener">http://huangronaldo.iteye.com/blog/1457567</a></p><h1 id="4-dbms-job用法"><a href="#4-dbms-job用法" class="headerlink" title="4. dbms_job用法"></a>4. dbms_job用法</h1><p>dbms_job，用于安排和管理作业队列，通过作业控制，使oracle数据库定期执行特定的任务。  </p><h2 id="4-1-dbms-job涉及到的知识点"><a href="#4-1-dbms-job涉及到的知识点" class="headerlink" title="4.1 dbms_job涉及到的知识点"></a>4.1 dbms_job涉及到的知识点</h2><p>1、创建job<br>variable jobno number;<br>dbms_job.submit(:jobno, —-job号<br> ‘your_procedure;’,—-执行的存储过程, ‘;’不能省略<br> next_date, —-下次执行时间<br> ‘interval’ —-每次间隔时间，interval以天为单位<br>);<br>–- 系统会自动分配一个任务号jobno。</p><p>2、删除job: dbms_job.remove(jobno); </p><p>3、修改要执行的操作: job:dbms_job.what(jobno, what);</p><p>4、修改下次执行时间：dbms_job.next_date(jobno, next_date);</p><p>5、修改间隔时间：dbms_job.interval(jobno, interval); </p><p>6、启动job: dbms_job.run(jobno);</p><p>7、停止job: dbms.broken(jobno, broken, nextdate); –broken为boolean值</p><h2 id="4-2-初始化相关参数job-queue-processes"><a href="#4-2-初始化相关参数job-queue-processes" class="headerlink" title="4.2 初始化相关参数job_queue_processes"></a>4.2 初始化相关参数job_queue_processes</h2><p>1、job_queue_process表示oracle能够并发的job的数量，当job_queue_process值为0时表示全部停止oracle的job。</p><p>2、查看job_queue_processes参数<br>方法一：<br>show parameter job_queue_process;<br>方法二：<br>select * from v$parameter where name=’job_queue_processes’;</p><p>3、修改job_queue_processes参数（感觉非必须，初始应该有合理值，mark察其用法 by xj）<br>alter system set job_queue_processes = 10;</p><h2 id="4-3-user-jobs表结构"><a href="#4-3-user-jobs表结构" class="headerlink" title="4.3 user_jobs表结构"></a>4.3 user_jobs表结构</h2><p>字段（列） 类型 描述<br>job number 任务的唯一标示号<br>log_user varchar2(30) 提交任务的用户<br>priv_user varchar2(30) 赋予任务权限的用户<br>schema_user varchar2(30) 对任务作语法分析的用户模式<br>last_date date 最后一次成功运行任务的时间<br>last_sec varchar2(8) 如hh24:mm:ss格式的last_date日期的小时，分钟和秒<br>this_date date 正在运行任务的开始时间，如果没有运行任务则为null<br>this_sec varchar2(8) 如hh24:mm:ss格式的this_date日期的小时，分钟和秒<br>next_date date 下一次定时运行任务的时间</p><h2 id="4-4-一个dbms-job使用的具体案例"><a href="#4-4-一个dbms-job使用的具体案例" class="headerlink" title="4.4 一个dbms_job使用的具体案例"></a>4.4 一个dbms_job使用的具体案例</h2><h3 id="4-4-1-在plsql中创建表"><a href="#4-4-1-在plsql中创建表" class="headerlink" title="4.4.1 在plsql中创建表"></a>4.4.1 在plsql中创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table tt(</span><br><span class="line"> id varchar2(30),</span><br><span class="line"> name varchar2(30)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Table created.</span><br></pre></td></tr></table></figure><h3 id="4-4-2-在plsql中创建存储过程"><a href="#4-4-2-在plsql中创建存储过程" class="headerlink" title="4.4.2 在plsql中创建存储过程"></a>4.4.2 在plsql中创建存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure proce_t is</span><br><span class="line">begin</span><br><span class="line"> insert into tt(id, name) values(&apos;1&apos;, to_char(sysdate, &apos;yyyy-mm-dd hh24:mi:ss&apos;));</span><br><span class="line"> commit;</span><br><span class="line">end proce_t;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">Procedure created.</span><br></pre></td></tr></table></figure><h3 id="4-4-3-创建job任务-1分钟执行一次"><a href="#4-4-3-创建job任务-1分钟执行一次" class="headerlink" title="4.4.3 创建job任务(1分钟执行一次)"></a>4.4.3 创建job任务(1分钟执行一次)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">variable jobno number;</span><br><span class="line">begin</span><br><span class="line"> dbms_job.submit(:jobno,&apos;proce_t;&apos;, sysdate, &apos;sysdate+1/24/60&apos;);</span><br><span class="line"> commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br></pre></td></tr></table></figure><h3 id="4-4-4-跟踪任务的情况-查看任务队列"><a href="#4-4-4-跟踪任务的情况-查看任务队列" class="headerlink" title="4.4.4 跟踪任务的情况(查看任务队列)"></a>4.4.4 跟踪任务的情况(查看任务队列)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 21-MAY-18          00:26:45                                  0 N</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>查看定时任务执行情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from tt;</span><br><span class="line"></span><br><span class="line">ID                             NAME</span><br><span class="line">------------------------------ ------------------------------</span><br><span class="line">1                              2018-05-21 00:25:45</span><br><span class="line">1                              2018-05-21 00:26:50</span><br><span class="line">1                              2018-05-21 00:27:55</span><br></pre></td></tr></table></figure></p><h3 id="4-4-5-停止定时任务"><a href="#4-4-5-停止定时任务" class="headerlink" title="4.4.5 停止定时任务"></a>4.4.5 停止定时任务</h3><h4 id="4-4-5-1-查看定时任务的job号"><a href="#4-4-5-1-查看定时任务的job号" class="headerlink" title="4.4.5.1 查看定时任务的job号"></a>4.4.5.1 查看定时任务的job号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 21-MAY-18          00:30:00                                  0 N</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><h4 id="4-4-5-2-停止一个已启动的定时任务"><a href="#4-4-5-2-停止一个已启动的定时任务" class="headerlink" title="4.4.5.2 停止一个已启动的定时任务"></a>4.4.5.2 停止一个已启动的定时任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line"> dbms_job.broken(1, true, sysdate);</span><br><span class="line"> commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">PL/SQL procedure successfully completed.</span><br></pre></td></tr></table></figure><h4 id="4-4-5-3-查看定时任务是否已停止成功"><a href="#4-4-5-3-查看定时任务是否已停止成功" class="headerlink" title="4.4.5.3 查看定时任务是否已停止成功"></a>4.4.5.3 查看定时任务是否已停止成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 01-JAN-00          00:00:00                                  0 Y</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>broken值为y，表示定时任务已停止。</p><h3 id="4-4-6-启动定时任务"><a href="#4-4-6-启动定时任务" class="headerlink" title="4.4.6 启动定时任务"></a>4.4.6 启动定时任务</h3><h4 id="4-4-6-1-查看停止定时任务"><a href="#4-4-6-1-查看停止定时任务" class="headerlink" title="4.4.6.1 查看停止定时任务"></a>4.4.6.1 查看停止定时任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 01-JAN-00          00:00:00                                  0 Y</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>broken值为y，表示定时任务已停止。</p><h4 id="4-4-6-2-启动定时任务"><a href="#4-4-6-2-启动定时任务" class="headerlink" title="4.4.6.2 启动定时任务"></a>4.4.6.2 启动定时任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line"> dbms_job.run(1);</span><br><span class="line"> commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">PL/SQL procedure successfully completed.</span><br></pre></td></tr></table></figure><h4 id="4-4-6-3-查看定时任务是否已启动"><a href="#4-4-6-3-查看定时任务是否已启动" class="headerlink" title="4.4.6.3 查看定时任务是否已启动"></a>4.4.6.3 查看定时任务是否已启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 21-MAY-18          00:34:40                                  0 N</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>broken值为n，表示定时任务启动成功。</p><h3 id="4-4-7-查看进程数"><a href="#4-4-7-查看进程数" class="headerlink" title="4.4.7 查看进程数"></a>4.4.7 查看进程数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameter job_queue_processes;</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">job_queue_processes                  integer     4000</span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>必须大于0，否则执行下面的命令修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system set job_queue_processes=10;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-8-再创建一个任务-每5分钟执行一次"><a href="#4-4-8-再创建一个任务-每5分钟执行一次" class="headerlink" title="4.4.8 再创建一个任务(每5分钟执行一次)"></a>4.4.8 再创建一个任务(每5分钟执行一次)</h3><p><strong>创建</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable jobno number;</span><br><span class="line">begin</span><br><span class="line"> dbms_job.submit(:jobno, &apos;proce_t;&apos;, sysdate, &apos;sysdate+1/24/12&apos;); --interval是以天为单位的</span><br><span class="line"> commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure></p><p><strong>执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job,next_date,next_sec,failures,broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 21-MAY-18          00:36:50                                  0 N</span><br><span class="line">         2 21-MAY-18          00:41:25                                  0 N</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure></p><h2 id="4-5-job运行时间的总结"><a href="#4-5-job运行时间的总结" class="headerlink" title="4.5 job运行时间的总结"></a>4.5 job运行时间的总结</h2><p>1:每分钟执行<br>Interval =&gt; TRUNC(sysdate,’mi’) + 1/(24<em>60)<br>2:每天定时执行<br>例如：每天的凌晨1点执行<br>Interval =&gt; TRUNC(sysdate) + 1 +1/(24)<br>3:每周定时执行<br>例如：每周一凌晨1点执行<br>Interval =&gt; TRUNC(next_day(sysdate,’星期一’))+1/24<br>4:每月定时执行<br>例如：每月1日凌晨1点执行<br>Interval =&gt;TRUNC(LAST_DAY(SYSDATE))+1+1/24<br>5:每季度定时执行<br>例如每季度的第一天凌晨1点执行<br>Interval =&gt; TRUNC(ADD_MONTHS(SYSDATE,3),’Q’) + 1/24<br>6:每半年定时执行<br>例如：每年7月1日和1月1日凌晨1点<br>Interval =&gt; ADD_MONTHS(trunc(sysdate,’yyyy’),6)+1/24<br>7:每年定时执行<br>例如：每年1月1日凌晨1点执行<br>Interval =&gt;ADD_MONTHS(trunc(sysdate,’yyyy’), 12)+1/24<br>job的运行频率设置<br>1.每天固定时间运行，比如早上8:10分钟：Trunc(Sysdate+1) + (8</em>60+10)/24<em>60<br>2.Toad中提供的：<br>每天：trunc(sysdate+1)<br>每周：trunc(sysdate+7)<br>每月：trunc(sysdate+30)<br>每个星期日：next_day(trunc(sysdate),’星期日’)<br>每天6点：trunc(sysdate+1)+6/24<br>半个小时：sysdate+30/(24</em>60)<br>3.每个小时的第15分钟运行，比如：8:15，9:15，10:15…：trunc(sysdate,’hh’)+(60+15)/(24*60) 。</p><p><strong><em>上文参见：</em></strong><br>oracle数据库定时任务dbms_job的用法详解<br><a href="http://www.jb51.net/article/92575.htm" target="_blank" rel="noopener">http://www.jb51.net/article/92575.htm</a></p><p><strong><em>更多详情可参见以下两篇文章，有关于CHANGE的介绍。</em></strong></p><p><em>更多dbms_job包的说明：</em><br><a href="http://wallimn.iteye.com/blog/519924" target="_blank" rel="noopener">http://wallimn.iteye.com/blog/519924</a></p><p><strong>PS:</strong><br>change实际就是改变当前某个job设置的工作参数，包括job、what、next_date和interval参数。<br>job参数是一个整数值，它唯一标识此工作。<br>what参数是由此工作运行的一块PL/SQL代码块。<br>next_date参数指示何时此工作将被执行。<br>interval参数指示一个工作重执行的频度。</p><p><em>关于一些参数的解释可以参照一下：</em><br><a href="https://www.cnblogs.com/chenjunjie/p/5054415.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenjunjie/p/5054415.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/oracle_12c.jpg&quot; alt=&quot;oracle12c&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://xiejing2014.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://xiejing2014.github.io/tags/oracle/"/>
    
      <category term="oracle function" scheme="http://xiejing2014.github.io/tags/oracle-function/"/>
    
  </entry>
  
  <entry>
    <title>用不同语言来遍历目录和文件</title>
    <link href="http://xiejing2014.github.io/2018/05/18/%E7%94%A8%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E6%9D%A5%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6/"/>
    <id>http://xiejing2014.github.io/2018/05/18/用不同语言来遍历目录和文件/</id>
    <published>2018-05-18T02:28:15.000Z</published>
    <updated>2018-05-21T17:20:43.989Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/thanks_for_watching.jpg" alt=""></p><p>最近翻移动硬盘，发现自己还短暂的写过两个月的perl语言，盘中赫然躺着一些perl脚本，其中一个便是实现的遍历目录及其包含的文件的脚本。<br>该功能无非就是利用递归来写代码，这里想用perl、python、shell和C语言分别对其进行编写，聊发少年狂而已。</p><h1 id="1、程序列表"><a href="#1、程序列表" class="headerlink" title="1、程序列表"></a>1、程序列表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost script]# ls -tlr</span><br><span class="line">total 28</span><br><span class="line">-rwxr--r--. 1 root root  276 May 17 19:16 shell_find.sh</span><br><span class="line">-rwxr--r--. 1 root root  444 May 17 19:17 python_find.py</span><br><span class="line">-rwxr--r--. 1 root root  782 May 17 19:18 perl_find.sh</span><br><span class="line">-rw-r--r--. 1 root root 1184 May 17 19:36 C_Find.c</span><br><span class="line">-rwxr-xr-x. 1 root root 9048 May 17 19:37 C_Find</span><br><span class="line">[root@localhost script]#</span><br></pre></td></tr></table></figure><h2 id="1-1-perl"><a href="#1-1-perl" class="headerlink" title="1.1 perl"></a>1.1 perl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/perl</span><br><span class="line"></span><br><span class="line">use strict;</span><br><span class="line"></span><br><span class="line">my @filelist;</span><br><span class="line">my $dir = &quot;../python&quot;;</span><br><span class="line"></span><br><span class="line">push(@filelist,&amp;findfile($dir));</span><br><span class="line">print join(&quot;\n&quot;,@filelist);</span><br><span class="line">print &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">sub findfile&#123;</span><br><span class="line">        my @filelist;</span><br><span class="line">        my $dir = $_[0];</span><br><span class="line">        opendir(DIR,$dir);</span><br><span class="line">        my @temp = grep(!/^\.\.?$/,readdir(DIR));</span><br><span class="line">        close(DIR);</span><br><span class="line">        my $count = @temp;</span><br><span class="line">        my $i; </span><br><span class="line">        my $tmpdir;</span><br><span class="line">        for($i = 0; $i &lt; $count; $i++)&#123;</span><br><span class="line">                $tmpdir = (); </span><br><span class="line">                $tmpdir = &quot;$dir/$temp[$i]&quot;;</span><br><span class="line">                if(-d &quot;$tmpdir&quot;)&#123;</span><br><span class="line">                        push(@filelist,$tmpdir);                                                                                                                                             </span><br><span class="line">                        push(@filelist,&amp;findfile(&quot;$tmpdir&quot;));</span><br><span class="line">                &#125;   </span><br><span class="line">                else &#123;</span><br><span class="line">                        push(@filelist,$tmpdir);</span><br><span class="line">                &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        return @filelist;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-python"><a href="#1-2-python" class="headerlink" title="1.2 python"></a>1.2 python</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/python3</span><br><span class="line"># coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">basedir = &apos;../python&apos;</span><br><span class="line">filelists = []</span><br><span class="line"></span><br><span class="line">def find(basedir):</span><br><span class="line">    global filelists</span><br><span class="line">    for parent,dirnames,filenames in os.walk(basedir):</span><br><span class="line">        for dirname in dirnames:</span><br><span class="line">            filelists.append(os.path.join(parent,dirname))                                                                                                                                   </span><br><span class="line">        for filename in filenames:</span><br><span class="line">            filelists.append(os.path.join(parent,filename))</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    find(basedir)</span><br><span class="line">    print(&apos;\n&apos;.join(filelists))</span><br></pre></td></tr></table></figure><h2 id="1-3-shell"><a href="#1-3-shell" class="headerlink" title="1.3 shell"></a>1.3 shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/bash</span><br><span class="line"></span><br><span class="line">set -o nounset</span><br><span class="line">set -o errexit</span><br><span class="line"></span><br><span class="line">function find()&#123;</span><br><span class="line">    for file in `ls $1`</span><br><span class="line">    do  </span><br><span class="line">        if [ -d $1&quot;/&quot;$file ]</span><br><span class="line">        then</span><br><span class="line">            echo $1&quot;/&quot;$file                                                                                                                                                                  </span><br><span class="line">            find $1&quot;/&quot;$file</span><br><span class="line">        else</span><br><span class="line">            echo $1&quot;/&quot;$file</span><br><span class="line">        fi  </span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find &quot;../python&quot;</span><br></pre></td></tr></table></figure><h2 id="1-4-C"><a href="#1-4-C" class="headerlink" title="1.4 C"></a>1.4 C</h2><p>源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/* list dir and files through C */                                                                                                                                                           </span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_PATH_LENGTH 512 </span><br><span class="line"></span><br><span class="line">int find(char *path)</span><br><span class="line">&#123;</span><br><span class="line">    DIR *ptr_dir;</span><br><span class="line">    struct dirent *dir_entry;</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line">    char *child_path;</span><br><span class="line"></span><br><span class="line">    child_path = (char*)malloc(sizeof(char)*MAX_PATH_LENGTH);</span><br><span class="line">    if(child_path == NULL)&#123;</span><br><span class="line">        printf(&quot;malloc child_path occurs errors.\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    memset(child_path,0x0,sizeof(char)*MAX_PATH_LENGTH);</span><br><span class="line"></span><br><span class="line">    ptr_dir = opendir(path);</span><br><span class="line">    while(( dir_entry = readdir(ptr_dir) ) != NULL)&#123;</span><br><span class="line">        if(dir_entry-&gt;d_type &amp; DT_DIR)&#123;</span><br><span class="line">            if(strcmp(dir_entry-&gt;d_name,&quot;.&quot;) == 0 ||  </span><br><span class="line">                    strcmp(dir_entry-&gt;d_name,&quot;..&quot;) == 0)&#123; </span><br><span class="line">                continue;</span><br><span class="line">            &#125;   </span><br><span class="line">            sprintf(child_path,&quot;%s/%s&quot;,path,dir_entry-&gt;d_name);</span><br><span class="line">            printf(&quot;%s\n&quot;,child_path);</span><br><span class="line">    </span><br><span class="line">            find(child_path);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%s/%s\n&quot;,path,dir_entry-&gt;d_name);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    free(child_path);</span><br><span class="line">    child_path = NULL;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    find(&quot;../python&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o C_Find C_Find.c</span><br></pre></td></tr></table></figure></p><h1 id="2、执行结果"><a href="#2、执行结果" class="headerlink" title="2、执行结果"></a>2、执行结果</h1><p>上述代码执行结果一致，输出文件列表的默认排序或有差别。<br>以shell脚本的执行结果为例，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost script]# ./shell_find.sh </span><br><span class="line">../python/countCodeLine2.py</span><br><span class="line">../python/countCodeLine.py</span><br><span class="line">../python/countCodeLine.py_ori</span><br><span class="line">../python/Django</span><br><span class="line">../python/How_to_be_pythonic</span><br><span class="line">../python/How_to_be_pythonic/add.c</span><br><span class="line">../python/How_to_be_pythonic/adder.so</span><br><span class="line">../python/How_to_be_pythonic/app_decrator.py</span><br><span class="line">../python/How_to_be_pythonic/cpython_api.py</span><br><span class="line">../python/How_to_be_pythonic/cpython_ctype.py</span><br><span class="line">../python/How_to_be_pythonic/cpython_SWIG.py</span><br><span class="line">../python/How_to_be_pythonic/debug.txt</span><br><span class="line">../python/How_to_be_pythonic/decrator.py</span><br><span class="line">../python/How_to_be_pythonic/def__.py</span><br><span class="line">../python/How_to_be_pythonic/enumerate.py</span><br><span class="line">../python/How_to_be_pythonic/exception.py</span><br><span class="line">../python/How_to_be_pythonic/forelse.py</span><br><span class="line">../python/How_to_be_pythonic/funccode1.py</span><br><span class="line">../python/How_to_be_pythonic/Generators.py</span><br><span class="line">../python/How_to_be_pythonic/kw-args.py</span><br><span class="line">../python/How_to_be_pythonic/out.log</span><br><span class="line">../python/How_to_be_pythonic/pprint.py</span><br><span class="line">../python/How_to_be_pythonic/set.py</span><br><span class="line">../python/How_to_be_pythonic/test3.py</span><br><span class="line">../python/How_to_be_pythonic/test.py</span><br><span class="line">[root@localhost script]#</span><br></pre></td></tr></table></figure></p><h1 id="3、后记"><a href="#3、后记" class="headerlink" title="3、后记"></a>3、后记</h1><ol><li>C语言的实现方法中，有关dirent、stat等结构体含义的描述，可参见：<br> <a href="http://www.360doc.com/content/15/0701/10/5470123_481878714.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/15/0701/10/5470123_481878714.shtml</a></li><li>代码中输出的是目录及文件，可调整。</li><li>对列出的文件可做进一步的条件筛选，如后缀判断等。</li><li>可比较时间，可优化。</li><li>本文原作者:不出名的刀客，转载请一同转发本文链接。</li><li>第一次网上写技术文，文有不对之处，欢迎指正。</li><li>另，小白正在学习python，欢迎大神留言指教。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/thanks_for_watching.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近翻移动硬盘，发现自己还短暂的写过两个月的perl语言，盘中赫然躺着一些perl脚本，其中一个便是实现的遍历目录及其包含的文件的脚本。&lt;br&gt;该功能无非就是
      
    
    </summary>
    
      <category term="开发经验" scheme="http://xiejing2014.github.io/categories/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="perl" scheme="http://xiejing2014.github.io/tags/perl/"/>
    
      <category term="python" scheme="http://xiejing2014.github.io/tags/python/"/>
    
      <category term="shell" scheme="http://xiejing2014.github.io/tags/shell/"/>
    
      <category term="C/C++" scheme="http://xiejing2014.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
