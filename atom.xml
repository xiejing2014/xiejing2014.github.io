<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莫失莫忘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiejing2014.github.io/"/>
  <updated>2018-06-01T06:02:44.956Z</updated>
  <id>http://xiejing2014.github.io/</id>
  
  <author>
    <name>不出名的刀客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>informix历史（转帖-2）</title>
    <link href="http://xiejing2014.github.io/2018/06/01/informix%E5%8E%86%E5%8F%B2%EF%BC%88%E8%BD%AC%E5%B8%96-2%EF%BC%89/"/>
    <id>http://xiejing2014.github.io/2018/06/01/informix历史（转帖-2）/</id>
    <published>2018-06-01T05:48:10.000Z</published>
    <updated>2018-06-01T06:02:44.956Z</updated>
    
    <content type="html"><![CDATA[<p>Informix在1980年成立，目的是为Unix等开放操作系统提供专业的关系型数据库产品。公司的名称Informix便是取自Information和Unix的结合。</p><p>Informix第一个真正支持SQL语言的关系数据库产品是InformixSE（StandardEngine）。InformixSE的特点是简单、轻便、适应性强。它的装机量非常之大，尤其是在当时的微机Unix环境下，成为主要的数据库产品。它也是第一个被移植到Linux上的商业数据库产品。</p><p>在90年代初，联机事务处理成为关系数据库越来越主要的应用，同时，Client/Server结构日渐兴起。为了满足基于Client/Server环境下联机事务处理的需要，Informix在其数据库产品中引入了Client/Server的概念，将应用对数据库的请求与数据库对请求的处理分割开来，推出了Informix-OnLine，OnLine的一个特点是数据的管理的重大改变，即数据表不再是单个的文件，而是数据库空间和逻辑设备。逻辑设备不仅可以建立在文件系统之上，还可以是硬盘的分区和裸设备。由此提高了数据的安全性。</p><p>1993年，为了克服多进程系统性能的局限性，Informix使用多线程机制重新改写数据库核心，次年初，Informix推出了采用被称为”动态可伸缩结构”（DSA）的InformixDynamicServer。除了应用线程机制以外，Informix在数据库核心中引入了虚处理器的概念，每个虚处理器就是一个Informix数据库服务器进程。在DynamicServer中，多条线程可以在虚处理器缓冲池中并行执行，而每个虚处理机又被实际的多处理机调度执行。更重要的是：为了执行高效性和多功能的调谐，Informix将虚处理器根据不同的处理任务进行了分类。每一类被优化以完成一种特定的功能。</p><p>到90年代后期，随着Internet的兴起，电子文档、图片、视频、空间信息、Internet/Web等应用潮水般涌入IT行业，而关系数据库所管理的数据类型仍停留在数字、字符串、日期等六七十年代的水平上，其处理能力便显得力不从心了。1992年，著名的数据库学者、Ingres的创始人加州大学伯克利分校的MichaelStonebraker教授提出对象关系数据库模型，从而找到了一条解决问题的有效途径。</p><p>1995年，Stonebraker及其研发组织的加入了Informix，使之在数据库发展方向上有了一个新的突破：1996年Informix推出了通用数据选件（Universal Data Option）。这是一个对象关系模型的数据库服务器；它与其他厂商中间件的解决方案不同，从关系数据库服务器内部的各个环节对数据库进行面向对象的扩充；将关系数据库的各种机制抽象化、通用化。UniversalDataOption采用了DynamicServer的所有底层技术，如DSA结构和并行处理，同时允许用户在数据库中建立复杂的数据类型及用户自定义的数据类型，同时可对这些数据类型定义各种操作和运算以实现对象的封装。在定义操作和运算时可以采用数据库过程语言、C语言，它们经注册后成为服务器的一部分。</p><p>1999年，Informix进一步将Universal Data Option进行了优化，为用户自定义数据类型和操作过程提供了完整的工具环境。同时在传统事务处理的性能超过了以往的Dynamic Server。新的数据库核心便被命名为IDS.2000。它的目标定位于下世纪基于Internet的复杂数据库应用。</p><p>事实上，Internet的普及从Web开始。Web应用以简便和图文并茂见长。但充斥整个系统的HTML文件又将我们不知不觉地带回了文件系统的时代。采用数据库管理Internet信息遇到的第一个挑战就是复杂信息的管理问题，Internet的出现将”数据”的概念在实际应用中扩大了。为此，自 1995年起，Informix便着手进行新一代数据库系统的设计。作为专业的数据库厂商，Informix首先针对Internet应用中数据类型的多样化，采用对象技术对关系数据库体系进行了扩展。与众不同之处在于，Informix并非将新的数据类型写死在数据库核心中，而是将数据库系统中各个环节充分地抽象化，使用户有能力定义和描述自己需要管理的数据类型，将可管理的数据类型扩展到无限，同时适应了未来应用发展的需要。这就是Informix今年新推出的数据库服务器–InformixDynamicServer.2000（简称IDS.2000）。</p><p>在IDS.2000中，Informix的另一重大贡献在于抽象化数据库的访问方法（索引机制和查询优化）并将其中接口开放。这样，用户便可以自己定义对复杂对象的全新的索引机制，并融入整个数据库服务器。在IDS.2000中，所有用户自定义的数据类型、操作、索引机制都将被系统与其内置的类型、操作和索引机制同等对待。IDS.2000将所有数据库操作纳入标准数据库SQL的范畴，在形式上与传统关系数据库完全兼容，但适应了”数据”概念拓展的需求，成为真正的通用数据库。Informix在IDS.2000之上增加了一系列核心扩展模块，构成了面向Internet的多功能数据库服务器 Informix Internet Foundation.2000。</p><p>INFORMIX主要产品分为三大部分：<br>　　 数据库服务器(数据库核心)<br>　　 应用开发工具<br>　　 网络数据库互联产品</p><p>数据库服务器有两种，作用都是提供数据操作和管理：<br>　　 SE：完全基于UNIX操作系统，主要针对非多媒体的较少用户数的应用<br>　　 ONLINE：针对大量用户的联机事务处理和多媒体应用环境</p><p>应用开发工具是用以开发应用程序必要的环境和工具，主要也有两个系列：<br>4GL：INFORMIX传统的基于字符界面的开发工具，该系列的主要产品有五个，他们是I-SQL、4GL RDS、4GL C COMPILER、4GL ID和ESQL/C；<br>NewEra：INFORMIX最新提供的具有事件驱动能力、面向对象的基于各种图形界面的开发工具。<br>INFORMIX的网络数据库互联产品：提供给用户基于多种工业标准的应用程序接口，通过它可以和其它遵守这些工业标准的数据库联接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Informix在1980年成立，目的是为Unix等开放操作系统提供专业的关系型数据库产品。公司的名称Informix便是取自Information和Unix的结合。&lt;/p&gt;
&lt;p&gt;Informix第一个真正支持SQL语言的关系数据库产品是InformixSE（Standa
      
    
    </summary>
    
      <category term="数据库" scheme="http://xiejing2014.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="informix" scheme="http://xiejing2014.github.io/tags/informix/"/>
    
  </entry>
  
  <entry>
    <title>Informix历史（转帖-1）</title>
    <link href="http://xiejing2014.github.io/2018/05/25/informix%E5%8E%86%E5%8F%B2%EF%BC%88%E8%BD%AC%E5%B8%96-1%EF%BC%89/"/>
    <id>http://xiejing2014.github.io/2018/05/25/informix历史（转帖-1）/</id>
    <published>2018-05-25T09:17:51.000Z</published>
    <updated>2018-06-01T05:43:16.005Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="steelblue">1980</font></strong><br>在一家早期的S-100/CP/M公司Cromemco工作的Roger Sippl和Laura King开发了一个基于ISAM技术的小型的关系数据库，作为一个报表记录器软件的一部分。<br>1980年，Sippl和King离开Cromemco去开发关系数据库系统（RDS）。他们的第一个<br>INFORMIX<br>INFORMIX<br>产品叫做马拉松（Marathon），本质上是一个他们以前那个ISAM作品的16位版本，并且在Onyx操作系统上发布，这种Onyx操作系统是一个为早期的ZiLOG微处理器开发的Unix操作系统。<br>在开发RDS的时候，他们把目光转移到了新兴的RDBMS市场，并且在1981年发布了他们自己的一个产品：Informix（INFORMation on unIX）。它包含了他们自己的Informer语言。它具备了ACE报表记录器的特性，用来把数据从数据库里释放出来，并且呈现给用户以供读取。它还具备了PERFORM屏幕格式工具的特性，可以让用户实现交互式的查询并且编辑数据库里的数据。这个产品的最终版本是1986年的3.30版。<br>在1985年，他们引进了一种新的基于SQL的查询引擎，作为INFORMIX-SQL（或ISQL）1.10版（1.00版一直没有发行）的一部分。这个产品同样包括了SQL和PERFORM的SQL变量。ISQL和早期的Informix产品最显著的区别就在于将数据库存取码分散至一个引擎进程中（sqlexec），而不是将其直接嵌入客户端，这样来为和用户的电脑分离开的数据库服务器上的客户端-服务端运算创造条件。而基础的基于ISAM的文件存储引擎就被称作C-ISAM。<br>尽管在上世纪80年代Informix一直扮演一个小角色，但是随着Unix和SQL在80年代走向流行，他们的命运随之改变。在1986年，他们已经强大到自己独立募股，而且将公司改名为Informix Software。他们的产品包括INFORMIX-SQL 2.00版和INFORMIX-4GL 1.00版，两个产品都包含了数据库引擎和开发工具（为程序员准备的I4GL，和为普通用户准备的ISQL）。<br>一系列的产品随之发布，包括最初被认为是INFORMIX-Turbo的新的查询引擎。Turbo利用了新式的，比C-ISAM更对多用户性能有好处的RSAM。在1989年的4.00版出版后，Turbo被命名为INFORMIX-OnLine（一部分原因是因为它允许服务器运行在运行时，并且用户正在修改数据，而数据库的备份照样连贯进行），而且最初的基于C-ISAM的服务器被工具（ISQL和I4GL）所分割开来，并且被命名为INFORMIX-SE（标准版）。在1990年年末的时候，Informix OnLine 5.00版本问世，而且包括了完整的对拥有两步式工作提交和存储过程的分布式交易的支持。在5.01版中增加了对触发器的支持。<br><strong><font color="steelblue">1988</font></strong><br>在1988年，Informix将Innovative Software公司收购，后者研发了著名的基于DOS和Unix的办公系统软件SmartWare，和具有革新意义基于Apple Macintosh平台的的电子制表软件WingZ。<br><strong><font color="steelblue">1994</font></strong><br>随着Informix在办公自动化领域的失败，1994年他们重新把精力集中到发展当中的数据库服务器市场。同年，在与Sequent Computer Systems的协作下，Infomix发布了具备动态可扩展结构（DSA）的6.00版的数据库服务器。<br>DSA将产品的核心引擎做了很大改动，支持了横向和纵向的并行功能。并且基于和很多先驱与软件生产商（比如Sun Microsystems，Hewlett-Packard）都相继追随的对称多处理系统完美搭配的多线程核心。这两种并行模式让产品在扩展性上处于市场领先地位，不论是OLTP还是data warehousing。<br>如今我们熟知的Informix Dynamic Server（当初考虑过命名为Obsidian，而后来命名为Informix OnLine Dynamic Server），它的第7版在1994年震撼了市场。当时正式对称多处理技术（SMP）系统刚刚开始盛行，而且Unix已经开始变为服务器操作系统的主流。第7版基本上成为领先于其他竞争者的一代产品，而且不断地在性能评测上胜出。这场胜利的结果使得Informix在1997年轻而易举地将Sybase挤下去，登上了数据库世界的亚军宝座。<br>在第7版的成功的基础上，Informix将他们核心数据库研发的投资分为两个焦点。第一个是一开始所谓的XMP（for eXtended Multi-Processing），后来演变成了第8版的生产线，也被称作 XPS（for eXtended Parallel Server）。这个焦点致力于data warehousing和高端平台的并行处理，包括像IBM的RS-6000/SP这样的shared-nothing平台。<br><strong><font color="steelblue">1995</font></strong><br>在1995年收购了IIIustra后，第二个焦点集中在object-relational数据库（O-R）技术。Informix在7.x版本的OnLine产品中集成了IIIustra的O-R映射和DataBlades，结果变成了Informix Universal Server（IUS），或者简单地说，就是第9版。<br>第8版（XPS）和第9版（IUS）都出现在1996年的市场上，令Informix成为第一个内建O-R支持的“big three”数据库公司（另外两个是Oracle和Sybase）。评论家们花了很多心思在DataBlades上，DataBlades后来非常流行，继与IIIustra的合伙后，又有了新架构。这让其他的软件生产商很着急，Oracle在1997年发布了支持时间序列的“嫁接”包，而Sybase让一家第三方公司为其制作了一个没有竞争力的附加产品包。<br><strong><font color="steelblue">1997</font></strong><br>在市场上的失败和公司的管理不当，掩盖了Informix技术上的成功。在1997年愚人节那天，Informix宣布他们第一个季度的收入比预期少了10亿美元。公司CEO Phillip White把这些差额怪罪在未能投入足够的精力在核心数据库业务上，而在object-relational技术上投入了太多资源。紧接着，大量的营业损失和裁员相继而来。Informix重审了1994年到1996年的利润，1990年代中期包括给合伙公司的软件许可证其实很大一部分都没有真正售出到终极用户手中，这样不规范的操作致使公司财政产生了超过20亿美元的泡沫。即使在White 1997年7月离开后，公司在1998年又来了一次财务重审。<br><strong><font color="steelblue">2001</font></strong><br>从2000年开始，Informix历史上的大事件再也不是集中在技术革新上了。从那一年开始，三月份，Informix购买了Ardent Software，一家自己本来就是收购和合并而来的公司。这次收购为他们那个时候已经很多了的数据库引擎又增加了两个多维引擎UniVerse和UniData（被简称为U2），不仅包括Informix传统的产品，还有Red Brick的面向datawarehouse的SQL引擎、100% Java版本的SQL，Cloudscape（后来被绑定在J2EE的参考安装包内）。<br>IBM接管<br>2000年7月，Ardent公司的前任CEO，Peter Gyenes，成为Informix的CEO，并且迅速重整了Informix以让其成为一个更诱人的期待别被别人收购的“猎物”。这样重要的一个决定是要把所有的数据库引擎技术，和应用程序与工具分离开来。<br>在2001年4月，IBM趁着这次重整，提出了一项来自与沃尔玛（Informix最大的客户）的建议，从Informix购买了数据库技术、品牌、未来开发计划（代码名为“Arrowhead”的内部工程）以及和这些相关的超过10万余计的用户基础。剩下的生产应用程序和工具的公司重新命名为Ascential Software。在2005年5月，IBM买下了Ascential，在IBM的Information Management Software的投资组合下重新聚合了Informix的资产。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;font color=&quot;steelblue&quot;&gt;1980&lt;/font&gt;&lt;/strong&gt;&lt;br&gt;在一家早期的S-100/CP/M公司Cromemco工作的Roger Sippl和Laura King开发了一个基于ISAM技术的小型的关系数据库，作为一个报表记
      
    
    </summary>
    
      <category term="数据库" scheme="http://xiejing2014.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="informix" scheme="http://xiejing2014.github.io/tags/informix/"/>
    
  </entry>
  
  <entry>
    <title>Oracle正则表达式函数</title>
    <link href="http://xiejing2014.github.io/2018/05/25/Oracle%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0/"/>
    <id>http://xiejing2014.github.io/2018/05/25/Oracle正则表达式函数/</id>
    <published>2018-05-25T03:25:46.000Z</published>
    <updated>2018-05-25T08:33:02.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/oracle_12c.jpg" alt="oracle12c"></p><a id="more"></a><p>Oracle使用正则表达式的4个主要函数：</p><p>1、regexp_like 只能用于条件表达式，和 like 类似，但是使用的正则表达式进行匹配，语法很简单：<br><img src="/images/oracle_regex/20100918104143377.gif" alt=""></p><p>2、regexp_substr 函数，和 substr 类似，用于拾取合符正则表达式描述的字符子串，语法如下：<br><img src="/images/oracle_regex/20100918104143840.gif" alt=""></p><p>3、regexp_instr 函数，和 instr 类似，用于标定符合正则表达式的字符子串的开始位置，语法如下：<br><img src="/images/oracle_regex/20100918104143534.gif" alt=""></p><p>4、regexp_replace 函数，和 replace 类似，用于替换符合正则表达式的字符串，语法如下：<br><img src="/images/oracle_regex/20100918104144147.gif" alt=""></p><p>这里解析一下几个参数的含义：</p><p>1、source_char，输入的字符串，可以是列名或者字符串常量、变量。</p><p>2、pattern，正则表达式。</p><p>3、match_parameter，匹配选项。</p><p>取值范围： i：大小写不敏感； c：大小写敏感；n：点号 . 不匹配换行符号；m：多行模式；x：扩展模式，忽略正则表达式中的空白字符。</p><p>4、position，标识从第几个字符开始正则表达式匹配。</p><p>5、occurrence，标识第几个匹配组。</p><p>6、replace_string，替换的字符串。</p><p><strong>示例：</strong></p><p><strong>基础数据准备</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表及测试数据</span><br><span class="line">create table tmp (</span><br><span class="line">  ID varchar2(60),</span><br><span class="line">  STR varchar2(60)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">insert into tmp values (&apos;like&apos;,&apos;a9999&apos;);</span><br><span class="line">insert into tmp values (&apos;like&apos;,&apos;a9c&apos;);</span><br><span class="line">insert into tmp values (&apos;like&apos;,&apos;A7007&apos;);</span><br><span class="line">insert into tmp values (&apos;like&apos;,&apos;123a34cc&apos;);</span><br><span class="line">insert into tmp values (&apos;substr&apos;,&apos;123,234,345&apos;);</span><br><span class="line">insert into tmp values (&apos;substr&apos;,&apos;12,34.56:78&apos;);</span><br><span class="line">insert into tmp values (&apos;substr&apos;,&apos;123456789&apos;);</span><br><span class="line">insert into tmp values (&apos;instr&apos;,&apos;192.168.0.1&apos;);</span><br><span class="line">insert into tmp values (&apos;replace&apos;,&apos;(020)12345678&apos;);</span><br><span class="line">insert into tmp values (&apos;replace&apos;,&apos;001517729C28&apos;);</span><br><span class="line"></span><br><span class="line">-- 查询插入结果</span><br><span class="line">SQL&gt; select count(*) from tmp;</span><br><span class="line"></span><br><span class="line">  COUNT(*)</span><br><span class="line">----------</span><br><span class="line">        10</span><br></pre></td></tr></table></figure></p><p><strong>regexp_like</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">-- regexp_like示例</span><br><span class="line">-- &apos;i&apos;忽略大小写</span><br><span class="line">SQL&gt; SELECT str from tmp where id=&apos;like&apos; and regexp_like(str,&apos;A\d+&apos;,&apos;i&apos;);</span><br><span class="line"></span><br><span class="line">STR</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">a9999</span><br><span class="line">a9c</span><br><span class="line">A7007</span><br><span class="line">123a34cc</span><br><span class="line"></span><br><span class="line">-- 不带&apos;c&apos;</span><br><span class="line">SQL&gt; select str from tmp where id=&apos;like&apos; and regexp_like(str, &apos;a\d+&apos;);</span><br><span class="line"></span><br><span class="line">STR</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">a9999</span><br><span class="line">a9c</span><br><span class="line">123a34cc</span><br><span class="line"></span><br><span class="line">-- 带&apos;c&apos;</span><br><span class="line">SQL&gt; SELECT str from tmp where id=&apos;like&apos; and regexp_like(str,&apos;A\d+&apos;,&apos;c&apos;);    </span><br><span class="line"></span><br><span class="line">STR</span><br><span class="line">--------------------</span><br><span class="line">A7007</span><br><span class="line"></span><br><span class="line">-- 匹配以a开头的</span><br><span class="line">SQL&gt; select str from tmp where id=&apos;like&apos; and regexp_like(str,&apos;^a\d+&apos;);</span><br><span class="line"></span><br><span class="line">STR</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">a9999</span><br><span class="line">a9c</span><br><span class="line"></span><br><span class="line">-- 匹配以a开头，以数字结尾的</span><br><span class="line">SQL&gt; SELECT str from tmp where id=&apos;like&apos; and regexp_like(str,&apos;^a\d+$&apos;);</span><br><span class="line"></span><br><span class="line">STR</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">a9999</span><br></pre></td></tr></table></figure></p><p><strong>regexp_substr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- regexp_substr示例1</span><br><span class="line">SELECT</span><br><span class="line">str,</span><br><span class="line">regexp_substr(str,&apos;[^,]+&apos;)     str_1_1,</span><br><span class="line">regexp_substr(str,&apos;[^,]+&apos;,1,1) str_1_1,</span><br><span class="line">regexp_substr(str,&apos;[^,]+&apos;,1,2) str_1_2,  -- occurrence 第几个匹配组</span><br><span class="line">regexp_substr(str,&apos;[^,]+&apos;,2,1) str_2_1   -- position 从第几个字符开始匹配</span><br><span class="line">from tmp</span><br><span class="line">where id=&apos;substr&apos;;</span><br></pre></td></tr></table></figure></p><p>查询结果：<br><img src="/images/oracle_regex/11.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- regexp_substr示例2</span><br><span class="line">SQL&gt; col str format a20</span><br><span class="line">SQL&gt; SELECT</span><br><span class="line">  2  STR,</span><br><span class="line">  3  REGEXP_SUBSTR(STR, &apos;\d&apos;) STR,</span><br><span class="line">  4  REGEXP_SUBSTR(STR, &apos;\d+&apos;, 1, 1) STR,</span><br><span class="line">  5  REGEXP_SUBSTR(STR, &apos;\d&#123;2&#125;&apos;, 1, 2) STR,</span><br><span class="line">  6  REGEXP_SUBSTR(STR, &apos;\d&#123;3&#125;&apos;, 2, 1) STR</span><br><span class="line">  7  FROM TMP</span><br><span class="line">  8  WHERE ID = &apos;substr&apos;;</span><br></pre></td></tr></table></figure><p>查询结果：<br><img src="/images/oracle_regex/22.png" alt=""></p><p><strong>regexp_instr</strong></p><p>略，以后补充。</p><p><strong>regexp_replace</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- regexp_replace示例</span><br><span class="line">SELECT STR,</span><br><span class="line">REGEXP_REPLACE(STR, &apos;020&apos;, &apos;GZ&apos;) STR,</span><br><span class="line">REGEXP_REPLACE(STR, &apos;(\d&#123;3&#125;)(\d&#123;3&#125;)&apos;, &apos;&lt;\2\1&gt;&apos;) STR -- 将第一、第二捕获组交换位置，用尖括号标识出来</span><br><span class="line">FROM TMP</span><br><span class="line">WHERE ID = &apos;replace&apos;;</span><br></pre></td></tr></table></figure></p><p>查询结果：<br><img src="/images/oracle_regex/33.png" alt=""></p><p><strong>综合示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 建表</span><br><span class="line">create table tmp1(</span><br><span class="line">id varchar2(60),</span><br><span class="line">str varchar2(512)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 插入测试数据</span><br><span class="line">insert into tmp1 values(&apos;test&apos;,&apos;020000080568179234090000010030040050040205090070080040050000060289634175010000020&apos;);</span><br><span class="line"></span><br><span class="line">-- 使用regex函数处理数据</span><br><span class="line">SQL&gt; select str,REGEXP_SUBSTR(str,&apos;\d&#123;9&#125;&apos;) as row_line from tmp1; </span><br><span class="line"></span><br><span class="line">STR                  ROW_LINE</span><br><span class="line">02000008056817923409 020000080</span><br><span class="line">00000100300400500402</span><br><span class="line">05090070080040050000</span><br><span class="line">060289634</span><br><span class="line"></span><br><span class="line">-- 未完待续</span><br></pre></td></tr></table></figure></p><p>查询结果：<br><img src="/images/oracle_regex/44.png" alt=""></p><p><strong>参考资源：</strong><br><a href="https://www.cnblogs.com/suinlove/p/3981454.html" target="_blank" rel="noopener">https://www.cnblogs.com/suinlove/p/3981454.html</a></p><p><a href="https://docs.oracle.com/database/121/SQLRF/conditions007.htm#SQLRF00501" target="_blank" rel="noopener">https://docs.oracle.com/database/121/SQLRF/conditions007.htm#SQLRF00501</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/oracle_12c.jpg&quot; alt=&quot;oracle12c&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://xiejing2014.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://xiejing2014.github.io/tags/oracle/"/>
    
      <category term="regex" scheme="http://xiejing2014.github.io/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>分享1文,30分钟速览Regex正则表达式</title>
    <link href="http://xiejing2014.github.io/2018/05/23/%E5%88%86%E4%BA%AB1%E6%96%87-30%E5%88%86%E9%92%9F%E9%80%9F%E8%A7%88Regex%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://xiejing2014.github.io/2018/05/23/分享1文-30分钟速览Regex正则表达式/</id>
    <published>2018-05-23T01:31:48.000Z</published>
    <updated>2018-05-23T14:45:25.407Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Regex.jpg" alt=""></p><a id="more"></a><p>最初接触正则表达式是在学习shell的时候，涉及到正则表达式的匹配。<br>后来，正则表达式在各处用得也逐渐开始多了起来。。<br>分享此文，记录一下。</p><p><strong>资料参考：</strong><a href="http://www.jb51.net/tools/zhengze.html" target="_blank" rel="noopener">http://www.jb51.net/tools/zhengze.html</a></p><p><strong>备注：以后遇到正则相关的内容或者一些开发中的问题，可以往本文添加。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Regex.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="关联知识点" scheme="http://xiejing2014.github.io/categories/%E5%85%B3%E8%81%94%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="正则表达式" scheme="http://xiejing2014.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>clearcase常用命令</title>
    <link href="http://xiejing2014.github.io/2018/05/22/clearcase%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://xiejing2014.github.io/2018/05/22/clearcase常用命令/</id>
    <published>2018-05-22T12:37:00.000Z</published>
    <updated>2018-05-25T01:43:22.469Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cc_1.jpg" alt=""></p><a id="more"></a><h1 id="1-常规操作"><a href="#1-常规操作" class="headerlink" title="1. 常规操作"></a>1. 常规操作</h1><h2 id="1-1-最基本的操作"><a href="#1-1-最基本的操作" class="headerlink" title="1.1 最基本的操作"></a>1.1 最基本的操作</h2><p>cleartool co -nc xxx.cpp<br>cleartool ci -nc xxx.cpp</p><h2 id="1-2-查看自己总共co了多少文件"><a href="#1-2-查看自己总共co了多少文件" class="headerlink" title="1.2 查看自己总共co了多少文件"></a>1.2 查看自己总共co了多少文件</h2><p>cleartool lscheckout -cview -me -avobs</p><h2 id="1-3-最有用的命令"><a href="#1-3-最有用的命令" class="headerlink" title="1.3 最有用的命令"></a>1.3 最有用的命令</h2><p>cleartool man xxx<br>cleartool help xxx</p><h2 id="1-4-新增目录和文件"><a href="#1-4-新增目录和文件" class="headerlink" title="1.4 新增目录和文件"></a>1.4 新增目录和文件</h2><p>cleartool mkdir -c comment new_dir<br>cleartool mkelem -c comment new_file.cpp</p><h2 id="1-5-放弃co某个文件"><a href="#1-5-放弃co某个文件" class="headerlink" title="1.5 放弃co某个文件"></a>1.5 放弃co某个文件</h2><p>cleartool unco -keep file.cpp           //保留当前所改动的文件<br>cleartool unco -rm   file.cpp</p><h2 id="1-6-主线、分支文件合并"><a href="#1-6-主线、分支文件合并" class="headerlink" title="1.6 主线、分支文件合并"></a>1.6 主线、分支文件合并</h2><p>//查找需要合并的文件<br>cleartool findmerge . -fversion /main/xxxx_path -print<br>//比较文件不同<br>cleartool diff file.cpp file.cpp@@/main/xxxx_path/LATEST<br>//查看最新版本<br>cleartool lsvtree file.cpp<br>//合并<br>cleartool merge -to file.cpp file.cpp@@/main/xxxx_path/LATEST file.cpp@@/main/LATEST</p><h2 id="1-7-标签相关"><a href="#1-7-标签相关" class="headerlink" title="1.7 标签相关"></a>1.7 标签相关</h2><p>//新建标签<br>cleartool mklbtype -nc TEST_LABEL<br>//给文件打标签<br>cleartool mklabel -r TEST_LABEL file.cpp<br>//删除标签<br>cleartool rmtype lbtype:TEST_LABEL<br>//给所有打上TEST_LABEL标签的文件打上TEST_LABEL2标签<br>cleartool mklabel -replace -version /main/TEST_LABEL TEST_LABEL2 *<br>//查找打上TEST_LABEL标签的所有文件<br>cleartool find . -version “lbtype(TEST_LABEL)” -print<br>//查找打上TEST_LABEL和TEST_LABEL2标签的文件<br>cleartool find . -element ‘lbtype_sub(TEST_LABEL) &amp;&amp; lbtype_sub(TEST_LABEL2)’ -print</p><h2 id="1-8-将整个目录导入clearcase"><a href="#1-8-将整个目录导入clearcase" class="headerlink" title="1.8 将整个目录导入clearcase"></a>1.8 将整个目录导入clearcase</h2><p>clearfsimport -recurse /xxx/xxx/xxx/src /view/zhuj/home/vobs/cc_account<br>/xxx/xxx/xxx/src目录（包括此目录下的所有目录和文件）被导入/view/zhuj/home/vobs/cc_account中（/view/zhuj/home/vobs/cc_account/src）</p><h1 id="2-clearcase常用命令集锦"><a href="#2-clearcase常用命令集锦" class="headerlink" title="2. clearcase常用命令集锦"></a>2. clearcase常用命令集锦</h1><h2 id="2-1-将整个目录导入clearcase"><a href="#2-1-将整个目录导入clearcase" class="headerlink" title="2.1 将整个目录导入clearcase"></a>2.1 将整个目录导入clearcase</h2><p>clearfsimport -r‘源路径’ ‘目标路径’</p><h2 id="2-2-加锁"><a href="#2-2-加锁" class="headerlink" title="2.2 加锁"></a>2.2 加锁</h2><p>find . -name ‘<em>.</em>‘ -exec ‘cleartool lock nuser userame1,username2 “%CLEARCASE_PN%”‘</p><h2 id="2-3-解锁"><a href="#2-3-解锁" class="headerlink" title="2.3 解锁"></a>2.3 解锁</h2><p>find . -name ‘<em>.</em>‘ -exec ‘cleartool unlock “%CLEARCASE_PN%”‘</p><h2 id="2-4-转换格式"><a href="#2-4-转换格式" class="headerlink" title="2.4 转换格式"></a>2.4 转换格式</h2><p>chtype -f compressed_file “fileName”</p><h2 id="2-5-查看VOB的基本信息和UUID"><a href="#2-5-查看VOB的基本信息和UUID" class="headerlink" title="2.5 查看VOB的基本信息和UUID"></a>2.5 查看VOB的基本信息和UUID</h2><p>des -l vob:.</p><h2 id="2-6-删除视图"><a href="#2-6-删除视图" class="headerlink" title="2.6 删除视图"></a>2.6 删除视图</h2><p>rmview -uuid “UUID”</p><h2 id="2-7-删除lost-found"><a href="#2-7-删除lost-found" class="headerlink" title="2.7 删除lost+found"></a>2.7 删除lost+found</h2><p>find . -name ‘<em>.</em>‘ -exec ‘cleartool rmelem -f “%CLEARCASE_PN%”‘</p><h2 id="2-8-查询某一天的修改记录"><a href="#2-8-查询某一天的修改记录" class="headerlink" title="2.8 查询某一天的修改记录"></a>2.8 查询某一天的修改记录</h2><p>cleartool lshis -r -since 07-dec</p><h2 id="2-9-最基本的操作"><a href="#2-9-最基本的操作" class="headerlink" title="2.9 最基本的操作"></a>2.9 最基本的操作</h2><p>cleartool co -nc filename<br>cleartool ci -nc filename</p><h2 id="2-10-查看自己总共co了多少文件"><a href="#2-10-查看自己总共co了多少文件" class="headerlink" title="2.10 查看自己总共co了多少文件"></a>2.10 查看自己总共co了多少文件</h2><p>cleartool lscheckout -cview –me -vobs</p><h2 id="2-11-make目录和文件"><a href="#2-11-make目录和文件" class="headerlink" title="2.11 make目录和文件"></a>2.11 make目录和文件</h2><p>cleartool mkdir -c comment newdirectory<br>cleartool mkelem -c comment newfilename</p><h2 id="2-12-主线、分支文件合并"><a href="#2-12-主线、分支文件合并" class="headerlink" title="2.12 主线、分支文件合并"></a>2.12 主线、分支文件合并</h2><p>//查找需要合并的文件<br>cleartool findmerge . -fversion /main/TEST_Path -print<br>//比较文件不同<br>cleartool diff filename [url=mailto:file.cpp@@/main/xxxx_path/LATEST]filename@@/main/TEST_Path/LATEST<br>//查看最新版本<br>cleartool lsvtree filename<br>//合并<br>cleartool merge -to filename [url=mailto:file.cpp@@/main/xxxx_path/LATEST]filename @@/main/TEST_path/LATEST [url=mailto:file.cpp@@/main/LATEST]filename @@/main/LATEST</p><h2 id="2-13-标签相关"><a href="#2-13-标签相关" class="headerlink" title="2.13 标签相关"></a>2.13 标签相关</h2><p>cleartool mklbtype -nc TEST_LABEL<br>cleartool mklabel -r TEST_LABEL filename<br>cleartool rmtype lbtype:TEST_LABEL<br>//给所有打上TEST_LABEL标签的文件打上TEST_LABEL标签<br>cleartool mklabel -replace -version /main/TEST_LABEL TEST_LABEL *<br>//查找打上TEST_LABEL标签的所有文件<br>cleartool find . -version “lbtype(TEST_LABEL)” -print<br>//查找打上TEST_LABEL和TEST_LABEL1标签的文件<br>cleartool find . -element ‘lbtype_sub(TEST_LABEL) &amp;&amp; lbtype_sub(TEST_LABEL1)’ -print</p><h2 id="2-14-察看某目录下的文件"><a href="#2-14-察看某目录下的文件" class="headerlink" title="2.14 察看某目录下的文件"></a>2.14 察看某目录下的文件</h2><p>ls</p><h2 id="2-15-man-help命令"><a href="#2-15-man-help命令" class="headerlink" title="2.15 man/help命令"></a>2.15 man/help命令</h2><p>cleartool man xxx<br>cleartool help xxx</p><h2 id="2-16-放弃co某个文件"><a href="#2-16-放弃co某个文件" class="headerlink" title="2.16 放弃co某个文件"></a>2.16 放弃co某个文件</h2><p>cleartool unco -keep filename<br>cleartool unco -rm filename</p><h2 id="2-17-更改VOB的Owner"><a href="#2-17-更改VOB的Owner" class="headerlink" title="2.17 更改VOB的Owner:"></a>2.17 更改VOB的Owner:</h2><p>cleartool protectvob –chown root /vob/vob.vbs</p><h2 id="2-18-更改VOB的Group"><a href="#2-18-更改VOB的Group" class="headerlink" title="2.18 更改VOB的Group:"></a>2.18 更改VOB的Group:</h2><p>cleartool protectvob –chgrp alluser /vob/vob.vbs</p><h2 id="2-19-增加Additional-Group"><a href="#2-19-增加Additional-Group" class="headerlink" title="2.19 增加Additional Group:"></a>2.19 增加Additional Group:</h2><p>cleartool protectvob –add_group group1 /vob/vob.vbs</p><h2 id="2-20-删除Additional-Group"><a href="#2-20-删除Additional-Group" class="headerlink" title="2.20 删除Additional Group:"></a>2.20 删除Additional Group:</h2><p>cleartool protectvob –delete_group group1 /vob/vob.vbs</p><h2 id="2-21-更改group、owner、mod"><a href="#2-21-更改group、owner、mod" class="headerlink" title="2.21 更改group、owner、mod"></a>2.21 更改group、owner、mod</h2><p>protect -r -chgrp groupname–chown username -chmod 770 .</p><h2 id="2-22-创建VOB"><a href="#2-22-创建VOB" class="headerlink" title="2.22 创建VOB"></a>2.22 创建VOB</h2><p>cleartool mkvob -tag /vobtags/test_code -c “Test” “D:\Data\Tets.vbs”</p><h2 id="2-23-Mount-vob"><a href="#2-23-Mount-vob" class="headerlink" title="2.23 Mount vob"></a>2.23 Mount vob</h2><p>Cleartool mount /vobtags/vob </p><h2 id="2-24-创建视图"><a href="#2-24-创建视图" class="headerlink" title="2.24 创建视图"></a>2.24 创建视图</h2><p>cleartool mkview –tag test /ccvob/views/test.vws </p><h2 id="2-25-设置当前视图"><a href="#2-25-设置当前视图" class="headerlink" title="2.25 设置当前视图"></a>2.25 设置当前视图</h2><p>cleartool setview test</p><h2 id="2-26-设置当前的activity"><a href="#2-26-设置当前的activity" class="headerlink" title="2.26 设置当前的activity"></a>2.26 设置当前的activity</h2><p>cleartool setactivity activityname</p><h2 id="2-27-Check-out"><a href="#2-27-Check-out" class="headerlink" title="2.27 Check out"></a>2.27 Check out</h2><p>Check out一个文件</p><p>Cleartool checkout [-reserve][-unreserve] filename</p><p>Check out前目录</p><p>Cleartool checkout .</p><p>Check out当前目录下所有文件</p><p>Cleartool Checkout –nc <em>.</em></p><p>Check out当前目录下所有的文件和目录中的文件</p><p>cleartool find . $file -exec ‘cleartool checkout -nc $CLEARCASE_PN’ </p><h2 id="2-28-Check-in"><a href="#2-28-Check-in" class="headerlink" title="2.28 Check in"></a>2.28 Check in</h2><p>Check in 一个文件</p><p>Cleartool checkin filename</p><p>Check in 当前目录<br>Cleartool checkin .</p><p>Check in 当前目录下所有文件.</p><p>Cleartool Checkin –nc <em>.</em></p><p>Check in当前目录下所有的文件和目录中的文件</p><p>cleartool find . $file -exec ‘cleartool checkin -nc –ide $CLEARCASE_PN’</p><p>以上内容来自：<a href="http://hi.baidu.com/is%CC%EC%B2%C5/blog/item/36bfbfc83cced1117f3e6fa0.html" target="_blank" rel="noopener">http://hi.baidu.com/is%CC%EC%B2%C5/blog/item/36bfbfc83cced1117f3e6fa0.html</a></p><h1 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h1><p>创建view：clt mkview -tag view_abcd /view_store/view_abcd.vws<br>设置view: clt setview view_abcd<br>编辑config specification: clt edcs</p><p>创建branch type：clt mkbrtype dbg_branch1_comments<br>在某个文件的当前branch上， 拉出一个branch：<br>clt mkbranch dbg_branch1_comments filename.c</p><p>now you have make branch on the file, and checked it out.<br>you can edit it with gvim.<br>After changed codes, you can complie it successfully, and test the result, you can check it in.<br>clt ci filename.c<br>If you want to check out it again:<br>clt co filename.c</p><p>To change the branch name to a formula name you can use the command:<br>clt rename brtype:dbg_branch1_comments brtype:crnumber_branch1_comments</p><p>To see the version tree of a file:<br>clt lsvtree -g filename.c</p><p>To see which files is included in a branch, you can edit a script like this find_branch.sh:</p><p>echo “$1”<br>cleartool find -avobs -element “brtype(“$1”)” -nxn -print | xargs cleart<br>ool ls -s|grep “$1”</p><p>To compare files, I write a useful script file mydiff.</p><p>You can use xcc&amp; to open graphic clearcase. So you can do most thing through the menu.</p><p>以上内容来自：<a href="http://www.diybl.com/course/4_webprogram/asp.net/netjs/20071020/78573.html" target="_blank" rel="noopener">http://www.diybl.com/course/4_webprogram/asp.net/netjs/20071020/78573.html</a></p><h1 id="4-clearcase实用命令"><a href="#4-clearcase实用命令" class="headerlink" title="4. clearcase实用命令"></a>4. clearcase实用命令</h1><p>查找分支上的文件<br>find . -branch brtype(branchname) -print<br>创建分支<br>mkbrtype -c “comment” branchname<br>创建Label<br>mklbtype -c “comment” labelname<br>用于 cleartool find 查询:<br>cleartool find -all -version “lbtype(REL1)” -print<br>find . -version ‘lbtype(LABEL)’ -print<br>锁分支命令<br>lock brtype:branchname<br>创建trigger<br>trigger已存在<br>mktrtype mktrtype -replace -element -all -preop mkelem -nusers shiquan -exec <a href="http://www.cnblogs.com/samcn/admin/file://192.168.1.5/cc_trigger/false.bat" target="_blank" rel="noopener">http://www.cnblogs.com/samcn/admin/file://192.168.1.5/cc_trigger/false.bat</a> NO_RM_MK<br>trigger不存在<br>mktrtype mktrtype -element -all -preop mkelem -nusers shiquan -exec <a href="http://www.cnblogs.com/samcn/admin/file://192.168.1.5/cc_trigger/false.bat" target="_blank" rel="noopener">http://www.cnblogs.com/samcn/admin/file://192.168.1.5/cc_trigger/false.bat</a> NO_RM_MK<br>日常开发人员常用命令</p><h1 id="5-开发人员常用命令"><a href="#5-开发人员常用命令" class="headerlink" title="5. 开发人员常用命令"></a>5. 开发人员常用命令</h1><h2 id="5-1-建立vob"><a href="#5-1-建立vob" class="headerlink" title="5.1 建立vob"></a>5.1 建立vob</h2><p>mkvob –tag /vobtags/vob1 –c “ VOB for project1” /vobstore/vob1.vbs</p><h2 id="5-2-Mount-vob"><a href="#5-2-Mount-vob" class="headerlink" title="5.2 Mount vob"></a>5.2 Mount vob</h2><p>Cleartool mount /vobtags/vob1</p><h2 id="5-3-创建视图"><a href="#5-3-创建视图" class="headerlink" title="5.3 创建视图"></a>5.3 创建视图</h2><p>cleartool mkview –tag test1 /ccvob/views/test1.vws</p><h2 id="5-4-设置当前视图"><a href="#5-4-设置当前视图" class="headerlink" title="5.4 设置当前视图"></a>5.4 设置当前视图</h2><p>cleartool setview test1</p><h2 id="5-5-在VOB的根目录下到入数据："><a href="#5-5-在VOB的根目录下到入数据：" class="headerlink" title="5.5 在VOB的根目录下到入数据："></a>5.5 在VOB的根目录下到入数据：</h2><p>clearfsimport –recurse –c “ comments “ /home/setup/* . ，注意命令的最后为圆点，表示当前目录。</p><h2 id="5-6-改变VOB的Owner"><a href="#5-6-改变VOB的Owner" class="headerlink" title="5.6 改变VOB的Owner:"></a>5.6 改变VOB的Owner:</h2><p>cleartool protectvob –chown root /vobstore/vob1.vbs</p><h2 id="5-7-改变VOB的Group"><a href="#5-7-改变VOB的Group" class="headerlink" title="5.7 改变VOB的Group:"></a>5.7 改变VOB的Group:</h2><p>cleartool protectvob –chgrp alluser /vobstore/vob1.vbs</p><h2 id="5-8-增加Additional-Group"><a href="#5-8-增加Additional-Group" class="headerlink" title="5.8 增加Additional Group:"></a>5.8 增加Additional Group:</h2><p>cleartool protectvob –add_group group1 /vobstore/vob1.vbs</p><h2 id="5-9-删除Additional-Group"><a href="#5-9-删除Additional-Group" class="headerlink" title="5.9 删除Additional Group:"></a>5.9 删除Additional Group:</h2><p>cleartool protectvob –delete_group group1 /vobstore/vob1.vbs<br>修改vob中数据的权限信息</p><h2 id="5-10-将jmccboss-VOB-中所有元素Owner-改成ccadmin，Group改成jmccboss"><a href="#5-10-将jmccboss-VOB-中所有元素Owner-改成ccadmin，Group改成jmccboss" class="headerlink" title="5.10 将jmccboss VOB 中所有元素Owner 改成ccadmin，Group改成jmccboss:"></a>5.10 将jmccboss VOB 中所有元素Owner 改成ccadmin，Group改成jmccboss:</h2><p>Cleartool protect –chown ccadmin –chgrp jmccboss .<br>.为vob根目录</p><h2 id="5-11-将jmccboss-VOB-中所有元素权限"><a href="#5-11-将jmccboss-VOB-中所有元素权限" class="headerlink" title="5.11 将jmccboss VOB 中所有元素权限"></a>5.11 将jmccboss VOB 中所有元素权限</h2><p> 改成对ccadmin（rwx），jmccboss(rwx)，其他VOB附属组成员（r-x）:<br>例： Cleartool protect –recurse –chmod 775 . ，</p><h2 id="5-12-Mount-vob"><a href="#5-12-Mount-vob" class="headerlink" title="5.12 Mount vob"></a>5.12 Mount vob</h2><p>Cleartool mount /vobtags/vob1</p><h2 id="5-13-创建视图"><a href="#5-13-创建视图" class="headerlink" title="5.13 创建视图"></a>5.13 创建视图</h2><p>cleartool mkview –tag test1 /ccvob/views/test1.vws</p><h2 id="5-14-设置当前视图"><a href="#5-14-设置当前视图" class="headerlink" title="5.14 设置当前视图"></a>5.14 设置当前视图</h2><p>cleartool setview test1</p><h2 id="5-15-在VOB的根目录下到入数据："><a href="#5-15-在VOB的根目录下到入数据：" class="headerlink" title="5.15 在VOB的根目录下到入数据："></a>5.15 在VOB的根目录下到入数据：</h2><p>clearfsimport –recurse –c “ comments “ /home/setup/* . ，注意命令的最后为圆点，表示当前目录。</p><h2 id="5-16-Check-out"><a href="#5-16-Check-out" class="headerlink" title="5.16 Check out"></a>5.16 Check out</h2><p>Cleartool checkout [-reserve][-unreserve] b.c    Check out一个文件<br>Cleartool checkout .   Check out当前目录<br>Cleartool Checkout –nc <em>.</em>    Check out当前目录下所有文件<br>cleartool find . $file -exec ‘cleartool checkout -nc $CLEARCASE_PN’<br>Check out当前目录下所有的文件和目录中的文件</p><h2 id="5-17-Check-in"><a href="#5-17-Check-in" class="headerlink" title="5.17 Check in"></a>5.17 Check in</h2><p>Cleartool checkin b.c    Check in 一个文件<br>Cleartool checkin .    Check in 当前目录<br>Cleartool Checkin –nc <em>.</em>   Check in 当前目录下所有文件.<br>cleartool find . $file -exec ‘cleartool checkin -nc –ide $CLEARCASE_PN’<br>Check in当前目录下所有的文件和目录中的文件 </p><h2 id="5-18-建立一个snapshot-view"><a href="#5-18-建立一个snapshot-view" class="headerlink" title="5.18 建立一个snapshot view"></a>5.18 建立一个snapshot view</h2><p>cleartool mkview –tag pat_2_snapshot_view –snapshot /viewstore/pat/myviews.vws</p><h2 id="5-19-编辑config-spe"><a href="#5-19-编辑config-spe" class="headerlink" title="5.19 编辑config spe"></a>5.19 编辑config spe</h2><p>Cleartool edcs</p><h2 id="5-20-更新snapshot-view"><a href="#5-20-更新snapshot-view" class="headerlink" title="5.20 更新snapshot view"></a>5.20 更新snapshot view</h2><p>cleartool update pat_2_snapshot_view</p><h2 id="5-21-设置当前的activity"><a href="#5-21-设置当前的activity" class="headerlink" title="5.21 设置当前的activity"></a>5.21 设置当前的activity</h2><p>cleartool setactivity activityname<br>      gaibian leixing: chtype binary_delta_file Estonian.r<br>错误 :clearfsimport: Error: Trouble was encountered importing the following elements:<br>        D:\work\shiquan_study\Broadcom070122\BCM_R2.10_A1\mmi\design\gui\res\ffs_preload\CD_5_2_6.dm</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/cc_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件版本管理" scheme="http://xiejing2014.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="clearcase" scheme="http://xiejing2014.github.io/tags/clearcase/"/>
    
  </entry>
  
  <entry>
    <title>Oracle某些函数学习记录（2018-05-21备忘）</title>
    <link href="http://xiejing2014.github.io/2018/05/21/Oracle%E6%9F%90%E4%BA%9B%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%882018-05-21%E5%A4%87%E5%BF%98%EF%BC%89/"/>
    <id>http://xiejing2014.github.io/2018/05/21/Oracle某些函数学习记录（2018-05-21备忘）/</id>
    <published>2018-05-21T10:09:01.000Z</published>
    <updated>2018-05-21T17:11:16.183Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/oracle_12c.jpg" alt="oracle12c"></p><a id="more"></a><p>最近需要了解一下oracle的有关函数，故寻觅一番，总结如下。</p><p>更多内容参考Oracle官网。<br>以下参考网络资源学习、摘录总结。</p><p>本文使用的本地oracle环境对参考资源进行了学习，当前版本为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from v$version;</span><br><span class="line"></span><br><span class="line">BANNER</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">    CON_ID</span><br><span class="line">----------</span><br><span class="line">Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production</span><br><span class="line">         0</span><br><span class="line"></span><br><span class="line">PL/SQL Release 12.2.0.1.0 - Production</span><br><span class="line">         0</span><br><span class="line"></span><br><span class="line">CORE    12.2.0.1.0      Production</span><br><span class="line">         0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BANNER</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">    CON_ID</span><br><span class="line">----------</span><br><span class="line">TNS for Linux: Version 12.2.0.1.0 - Production</span><br><span class="line">         0</span><br><span class="line"></span><br><span class="line">NLSRTL Version 12.2.0.1.0 - Production</span><br><span class="line">         0</span><br></pre></td></tr></table></figure></p><h1 id="1-DBMS-OBFUSCATION-TOOLKIT-MD5和Utl-Raw-Cast-To-Raw"><a href="#1-DBMS-OBFUSCATION-TOOLKIT-MD5和Utl-Raw-Cast-To-Raw" class="headerlink" title="1. DBMS_OBFUSCATION_TOOLKIT.MD5和Utl_Raw.Cast_To_Raw"></a>1. DBMS_OBFUSCATION_TOOLKIT.MD5和Utl_Raw.Cast_To_Raw</h1><p>DBMS_OBFUSCATION_TOOLKIT.MD5是MD5编码的数据包函数，可以直接在SQL中进行调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select Utl_Raw.Cast_To_Raw(sys.dbms_obfuscation_toolkit.md5(input_string =&gt; &apos;111&apos;)) from dual;</span><br><span class="line"></span><br><span class="line">UTL_RAW.CAST_TO_RAW(SYS.DBMS_OBFUSCATION_TOOLKIT.MD5(INPUT_STRING=&gt;&apos;111&apos;))</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">698D51A19D8A121CE581499D7B701668</span><br></pre></td></tr></table></figure></p><p>其结果返回的字串为RAW类型，要正确显示的话，需要经过Utl_Raw.Cast_To_Raw转换。<br>关于RAW类型，可详见本文第2节说明。</p><h1 id="2-RAW类型"><a href="#2-RAW类型" class="headerlink" title="2. RAW类型"></a>2. RAW类型</h1><p>oracle中用于保存位串的数据类型是RAW或者LONG RAW。<br>RAW类似于CHAR，声明方式为RAW(L)，L为单位，以字节表示，作为数据库列最大为2000，作为变量最大32767字节。<br>LONG RAW，类似于LONG，作为数据库列最大存储2G字节的数据，作为变量最大32760字节<br>RAW类型的好处就是：在网络中的计算机之间传输 RAW 数据时，或者使用 Oracle 实用程序将 RAW 数据从一个数据库移到另一个数据库时，Oracle服务器不执行字符集转换。存储实际列值所需要的字节数大小随每行大小而异，最多为 2000字节。可能这样的数据类型在数据库效率上会提高，而且对数据由于字符集的不同而导致的不一致的可能性在这边也排除了。<br>RAW保存的为16进制数，对应每个字符的ASCII码。常见的两个函数为utl_raw.cast_to_raw([varchar2]) 和utl_raw.cast_to_varchar2([raw])。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select utl_raw.cast_to_raw(&apos;甲骨文&apos;) name from dual;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">E794B2E9AAA8E69687</span><br><span class="line"></span><br><span class="line">SQL&gt; </span><br><span class="line">SQL&gt; select utl_raw.cast_to_varchar2(&apos;E794B2E9AAA8E69687&apos;) name  from dual;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">甲骨文</span><br></pre></td></tr></table></figure></p><p>题外话：使用SQL语句时，注意SERVER端和CLIENT端的字符集得一致，否则查询可能中文乱码。<br>SERVER端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select userenv(&apos;language&apos;) from dual;</span><br><span class="line"></span><br><span class="line">USERENV(&apos;LANGUAGE&apos;)</span><br><span class="line">----------------------------------------------------</span><br><span class="line">AMERICAN_CHINA.AL32UTF8</span><br></pre></td></tr></table></figure></p><p>CLIENT终端调整为显示一致：(如下临时调整)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NLS_LANG=&quot;AMERICAN_CHINA.AL32UTF8&quot;</span><br></pre></td></tr></table></figure></p><p>调整之后，对应终端能够正常显示中文。</p><p><strong><em>上述1,2节内容亦可参照以下链接：</em></strong><br><a href="https://blog.csdn.net/lwei_998/article/details/6070689" target="_blank" rel="noopener">https://blog.csdn.net/lwei_998/article/details/6070689</a><br><a href="https://blog.csdn.net/john2522/article/details/8124087" target="_blank" rel="noopener">https://blog.csdn.net/john2522/article/details/8124087</a><br>(或者<a href="https://blog.csdn.net/afzaici/article/details/51669495" target="_blank" rel="noopener">https://blog.csdn.net/afzaici/article/details/51669495</a><br><a href="http://blog.chinaunix.net/uid-90674-id-2436668.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-90674-id-2436668.html</a><br>)</p><h1 id="3-XMLTYPE操作，学习extract-和extractvalue"><a href="#3-XMLTYPE操作，学习extract-和extractvalue" class="headerlink" title="3. XMLTYPE操作，学习extract()和extractvalue()"></a>3. XMLTYPE操作，学习extract()和extractvalue()</h1><h2 id="3-1-特性概述"><a href="#3-1-特性概述" class="headerlink" title="3.1 特性概述"></a>3.1 特性概述</h2><p>对于文件等复杂且大体积的数据对象，Oracle通常采用LOB类型的变量来进行存储。对于XML数据文件，Oracle提供了XMLTYPE的数据类型。xmltype提供了适合的保存、检索和操作的支持。以下为一些特性介绍：<br>作为xmltype，Oracle会在数据表上建立一个clob类型的系统列，用于协助保存数据。<br><strong><em>可参考“xmltype类型浅析”一文：</em></strong><br><a href="https://www.linuxidc.com/Linux/2017-03/141678.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-03/141678.htm</a><br><strong><em>对于LOB类型，可参考“Oracle LOB类型介绍”一文：</em></strong><br><a href="https://blog.csdn.net/bbliutao/article/details/19707169" target="_blank" rel="noopener">https://blog.csdn.net/bbliutao/article/details/19707169</a></p><h2 id="3-2-XMLTYPE简单操作实例"><a href="#3-2-XMLTYPE简单操作实例" class="headerlink" title="3.2 XMLTYPE简单操作实例"></a>3.2 XMLTYPE简单操作实例</h2><h3 id="3-2-1-创建test-xml文件"><a href="#3-2-1-创建test-xml文件" class="headerlink" title="3.2.1 创建test.xml文件"></a>3.2.1 创建test.xml文件</h3><p>文件路径及名称：/home/oracle/xml/test.xml<br>xml格式文件，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;collection xmlns=&quot;&quot;&gt;</span><br><span class="line">  &lt;record&gt;</span><br><span class="line">    &lt;leader&gt;-----nam0-22-----^^^450-&lt;/leader&gt;</span><br><span class="line">    &lt;datafield tag=&quot;200&quot; ind1=&quot;1&quot; ind2=&quot; &quot;&gt;</span><br><span class="line">      &lt;subfield code=&quot;a&quot;&gt;抗震救灾&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;f&quot;&gt;奥运会&lt;/subfield&gt;</span><br><span class="line">    &lt;/datafield&gt;</span><br><span class="line">    &lt;datafield tag=&quot;209&quot; ind1=&quot; &quot; ind2=&quot; &quot;&gt;</span><br><span class="line">      &lt;subfield code=&quot;a&quot;&gt;经济学&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;b&quot;&gt;计算机&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;c&quot;&gt;10001&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;d&quot;&gt;2005-07-09&lt;/subfield&gt;</span><br><span class="line">    &lt;/datafield&gt;</span><br><span class="line">    &lt;datafield tag=&quot;610&quot; ind1=&quot;0&quot; ind2=&quot; &quot;&gt;</span><br><span class="line">       &lt;subfield code=&quot;a&quot;&gt;计算机&lt;/subfield&gt;</span><br><span class="line">       &lt;subfield code=&quot;a&quot;&gt;笔记本&lt;/subfield&gt;</span><br><span class="line">    &lt;/datafield&gt;</span><br><span class="line">  &lt;/record&gt;</span><br><span class="line">&lt;/collection&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-2-创建存放XML文件的表"><a href="#3-2-2-创建存放XML文件的表" class="headerlink" title="3.2.2 创建存放XML文件的表"></a>3.2.2 创建存放XML文件的表</h3><p><strong>建表</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create table xmlexample(</span><br><span class="line">    ID varchar2(60),</span><br><span class="line">    name varchar2(60),</span><br><span class="line">    data xmltype   </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">Table created.</span><br></pre></td></tr></table></figure></p><p><strong>插入数据</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create directory XMLPATH_TEST as &apos;/home/oracle/xml&apos;;</span><br><span class="line"></span><br><span class="line">Directory created.</span><br><span class="line"></span><br><span class="line">insert into xmlexample(id,name,data)</span><br><span class="line">values(sys_guid(),&apos;my document&apos;,</span><br><span class="line">        xmltype</span><br><span class="line">        (</span><br><span class="line">         bfilename(&apos;XMLPATH_TEST&apos;,&apos;test.xml&apos;),</span><br><span class="line">         nls_charset_id(&apos;AL32UTF8&apos;)</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>查询插入结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from xmlexample;</span><br><span class="line"></span><br><span class="line">ID</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">NAME</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">DATA</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">6CB32CE193E2D536E055000000000001</span><br><span class="line">my document</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;collection xmlns=&quot;&quot;&gt;</span><br><span class="line">  &lt;record&gt;</span><br><span class="line">    &lt;lea</span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-3-extractvalue-函数的使用"><a href="#3-2-3-extractvalue-函数的使用" class="headerlink" title="3.2.3 extractvalue()函数的使用"></a>3.2.3 extractvalue()函数的使用</h3><p>Oracle提供对XML文件的检索功能（extractvalue），extractvalue只能返回一个节点的一个值，具体操作方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select id,name,extractvalue(x.data,&apos;/collection/record/leader&apos;) as A from xmlexample x;</span><br><span class="line"></span><br><span class="line">ID</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">NAME</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">A</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">6CB32CE193E2D536E055000000000001</span><br><span class="line">my document</span><br><span class="line">-----nam0-22-----^^^450-</span><br></pre></td></tr></table></figure></p><p>如果该节点有两个值，则系统提示错误。</p><h3 id="3-2-4-extract-函数的使用"><a href="#3-2-4-extract-函数的使用" class="headerlink" title="3.2.4 extract()函数的使用"></a>3.2.4 extract()函数的使用</h3><p>如果想查询所有subfield的值就要用到extract()，它可以返回一个节点下的所有值。操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select id,name, extract(x.data,&apos;/collection/record/datafield/subfield&apos;) as A from xmlexample x;</span><br><span class="line"></span><br><span class="line">ID</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">NAME</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">A</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">6CB32CE193E2D536E055000000000001</span><br><span class="line">my document</span><br><span class="line">&lt;subfield code=&quot;a&quot;&gt;抗震救灾&lt;/subfield&gt;</span><br><span class="line">&lt;subfield code=&quot;f&quot;&gt;奥运会&lt;/subfiel</span><br></pre></td></tr></table></figure></p><p>可以看到它返回的是XML格式的。如果我们想只返回它的值就要是用两个函数了。</p><h3 id="3-2-5-table和XMLSequence"><a href="#3-2-5-table和XMLSequence" class="headerlink" title="3.2.5 table和XMLSequence"></a>3.2.5 table和XMLSequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select extractValue(value(i),&apos;/subfield&apos;) xx </span><br><span class="line">  2   from xmlexample x,</span><br><span class="line">  3   table(XMLSequence(extract(x.data,&apos;/collection/record/datafield/subfield&apos;))) i;</span><br><span class="line"></span><br><span class="line">XX</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">抗震救灾</span><br><span class="line">奥运会</span><br><span class="line">经济学</span><br><span class="line">计算机</span><br><span class="line">10001</span><br><span class="line">2005-07-09</span><br><span class="line">计算机</span><br><span class="line">笔记本</span><br><span class="line"></span><br><span class="line">8 rows selected.</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-6-检索出特定的节点的特定值"><a href="#3-2-6-检索出特定的节点的特定值" class="headerlink" title="3.2.6 检索出特定的节点的特定值"></a>3.2.6 检索出特定的节点的特定值</h3><p>有时候我们在实际操作的时候并不是检索出所有值，而是根据条件查询出我们所需要的信息。如果我们想检索出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;datafield tag=&quot;209&quot; ind1=&quot; &quot; ind2=&quot; &quot;&gt;</span><br><span class="line">&lt;subfield code=&quot;a&quot;&gt;经济学&lt;/subfield&gt;</span><br></pre></td></tr></table></figure></p><p>中的值-经济学<br>操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select id,name,extractvalue(x.data,&apos;/collection/record/datafield[@tag=&quot;209&quot;]/subfield[@code=&quot;a&quot;]&apos;) as A </span><br><span class="line">  2  from xmlexample x;</span><br><span class="line"></span><br><span class="line">ID</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">NAME</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">A</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">6CB32CE193E2D536E055000000000001</span><br><span class="line">my document</span><br><span class="line">经济学</span><br></pre></td></tr></table></figure></p><h3 id="3-2-7-XMLTYPE小结"><a href="#3-2-7-XMLTYPE小结" class="headerlink" title="3.2.7 XMLTYPE小结"></a>3.2.7 XMLTYPE小结</h3><p>Oracle对于XMLType的操作有很多种，还要靠大家自己去发现。数据库对XML的检索就是把XML的节点当作一个列来检索，而不同的是表里装的是二维的数据，而XML中可以装N维。还有就是，表中列不存在就会提示无效标识符，如果节点不存在，则检索出NULL，不会报错。所以，对与XML文件的操作通常是通过视图来完成。</p><p>以上学习内容参照：<a href="https://www.cnblogs.com/millen/archive/2011/12/28/2304410.html" target="_blank" rel="noopener">https://www.cnblogs.com/millen/archive/2011/12/28/2304410.html</a><br>关于Oracle中XML函数的接口介绍，可参见下文：<br><a href="http://huangronaldo.iteye.com/blog/1457567" target="_blank" rel="noopener">http://huangronaldo.iteye.com/blog/1457567</a></p><h1 id="4-dbms-job用法"><a href="#4-dbms-job用法" class="headerlink" title="4. dbms_job用法"></a>4. dbms_job用法</h1><p>dbms_job，用于安排和管理作业队列，通过作业控制，使oracle数据库定期执行特定的任务。  </p><h2 id="4-1-dbms-job涉及到的知识点"><a href="#4-1-dbms-job涉及到的知识点" class="headerlink" title="4.1 dbms_job涉及到的知识点"></a>4.1 dbms_job涉及到的知识点</h2><p>1、创建job<br>variable jobno number;<br>dbms_job.submit(:jobno, —-job号<br> ‘your_procedure;’,—-执行的存储过程, ‘;’不能省略<br> next_date, —-下次执行时间<br> ‘interval’ —-每次间隔时间，interval以天为单位<br>);<br>–- 系统会自动分配一个任务号jobno。</p><p>2、删除job: dbms_job.remove(jobno); </p><p>3、修改要执行的操作: job:dbms_job.what(jobno, what);</p><p>4、修改下次执行时间：dbms_job.next_date(jobno, next_date);</p><p>5、修改间隔时间：dbms_job.interval(jobno, interval); </p><p>6、启动job: dbms_job.run(jobno);</p><p>7、停止job: dbms.broken(jobno, broken, nextdate); –broken为boolean值</p><h2 id="4-2-初始化相关参数job-queue-processes"><a href="#4-2-初始化相关参数job-queue-processes" class="headerlink" title="4.2 初始化相关参数job_queue_processes"></a>4.2 初始化相关参数job_queue_processes</h2><p>1、job_queue_process表示oracle能够并发的job的数量，当job_queue_process值为0时表示全部停止oracle的job。</p><p>2、查看job_queue_processes参数<br>方法一：<br>show parameter job_queue_process;<br>方法二：<br>select * from v$parameter where name=’job_queue_processes’;</p><p>3、修改job_queue_processes参数（感觉非必须，初始应该有合理值，mark察其用法 by xj）<br>alter system set job_queue_processes = 10;</p><h2 id="4-3-user-jobs表结构"><a href="#4-3-user-jobs表结构" class="headerlink" title="4.3 user_jobs表结构"></a>4.3 user_jobs表结构</h2><p>字段（列） 类型 描述<br>job number 任务的唯一标示号<br>log_user varchar2(30) 提交任务的用户<br>priv_user varchar2(30) 赋予任务权限的用户<br>schema_user varchar2(30) 对任务作语法分析的用户模式<br>last_date date 最后一次成功运行任务的时间<br>last_sec varchar2(8) 如hh24:mm:ss格式的last_date日期的小时，分钟和秒<br>this_date date 正在运行任务的开始时间，如果没有运行任务则为null<br>this_sec varchar2(8) 如hh24:mm:ss格式的this_date日期的小时，分钟和秒<br>next_date date 下一次定时运行任务的时间</p><h2 id="4-4-一个dbms-job使用的具体案例"><a href="#4-4-一个dbms-job使用的具体案例" class="headerlink" title="4.4 一个dbms_job使用的具体案例"></a>4.4 一个dbms_job使用的具体案例</h2><h3 id="4-4-1-在plsql中创建表"><a href="#4-4-1-在plsql中创建表" class="headerlink" title="4.4.1 在plsql中创建表"></a>4.4.1 在plsql中创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table tt(</span><br><span class="line"> id varchar2(30),</span><br><span class="line"> name varchar2(30)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Table created.</span><br></pre></td></tr></table></figure><h3 id="4-4-2-在plsql中创建存储过程"><a href="#4-4-2-在plsql中创建存储过程" class="headerlink" title="4.4.2 在plsql中创建存储过程"></a>4.4.2 在plsql中创建存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure proce_t is</span><br><span class="line">begin</span><br><span class="line"> insert into tt(id, name) values(&apos;1&apos;, to_char(sysdate, &apos;yyyy-mm-dd hh24:mi:ss&apos;));</span><br><span class="line"> commit;</span><br><span class="line">end proce_t;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">Procedure created.</span><br></pre></td></tr></table></figure><h3 id="4-4-3-创建job任务-1分钟执行一次"><a href="#4-4-3-创建job任务-1分钟执行一次" class="headerlink" title="4.4.3 创建job任务(1分钟执行一次)"></a>4.4.3 创建job任务(1分钟执行一次)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">variable jobno number;</span><br><span class="line">begin</span><br><span class="line"> dbms_job.submit(:jobno,&apos;proce_t;&apos;, sysdate, &apos;sysdate+1/24/60&apos;);</span><br><span class="line"> commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br></pre></td></tr></table></figure><h3 id="4-4-4-跟踪任务的情况-查看任务队列"><a href="#4-4-4-跟踪任务的情况-查看任务队列" class="headerlink" title="4.4.4 跟踪任务的情况(查看任务队列)"></a>4.4.4 跟踪任务的情况(查看任务队列)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 21-MAY-18          00:26:45                                  0 N</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>查看定时任务执行情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from tt;</span><br><span class="line"></span><br><span class="line">ID                             NAME</span><br><span class="line">------------------------------ ------------------------------</span><br><span class="line">1                              2018-05-21 00:25:45</span><br><span class="line">1                              2018-05-21 00:26:50</span><br><span class="line">1                              2018-05-21 00:27:55</span><br></pre></td></tr></table></figure></p><h3 id="4-4-5-停止定时任务"><a href="#4-4-5-停止定时任务" class="headerlink" title="4.4.5 停止定时任务"></a>4.4.5 停止定时任务</h3><h4 id="4-4-5-1-查看定时任务的job号"><a href="#4-4-5-1-查看定时任务的job号" class="headerlink" title="4.4.5.1 查看定时任务的job号"></a>4.4.5.1 查看定时任务的job号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 21-MAY-18          00:30:00                                  0 N</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><h4 id="4-4-5-2-停止一个已启动的定时任务"><a href="#4-4-5-2-停止一个已启动的定时任务" class="headerlink" title="4.4.5.2 停止一个已启动的定时任务"></a>4.4.5.2 停止一个已启动的定时任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line"> dbms_job.broken(1, true, sysdate);</span><br><span class="line"> commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">PL/SQL procedure successfully completed.</span><br></pre></td></tr></table></figure><h4 id="4-4-5-3-查看定时任务是否已停止成功"><a href="#4-4-5-3-查看定时任务是否已停止成功" class="headerlink" title="4.4.5.3 查看定时任务是否已停止成功"></a>4.4.5.3 查看定时任务是否已停止成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 01-JAN-00          00:00:00                                  0 Y</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>broken值为y，表示定时任务已停止。</p><h3 id="4-4-6-启动定时任务"><a href="#4-4-6-启动定时任务" class="headerlink" title="4.4.6 启动定时任务"></a>4.4.6 启动定时任务</h3><h4 id="4-4-6-1-查看停止定时任务"><a href="#4-4-6-1-查看停止定时任务" class="headerlink" title="4.4.6.1 查看停止定时任务"></a>4.4.6.1 查看停止定时任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 01-JAN-00          00:00:00                                  0 Y</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>broken值为y，表示定时任务已停止。</p><h4 id="4-4-6-2-启动定时任务"><a href="#4-4-6-2-启动定时任务" class="headerlink" title="4.4.6.2 启动定时任务"></a>4.4.6.2 启动定时任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line"> dbms_job.run(1);</span><br><span class="line"> commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">PL/SQL procedure successfully completed.</span><br></pre></td></tr></table></figure><h4 id="4-4-6-3-查看定时任务是否已启动"><a href="#4-4-6-3-查看定时任务是否已启动" class="headerlink" title="4.4.6.3 查看定时任务是否已启动"></a>4.4.6.3 查看定时任务是否已启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job, next_date, next_sec, failures, broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 21-MAY-18          00:34:40                                  0 N</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>broken值为n，表示定时任务启动成功。</p><h3 id="4-4-7-查看进程数"><a href="#4-4-7-查看进程数" class="headerlink" title="4.4.7 查看进程数"></a>4.4.7 查看进程数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameter job_queue_processes;</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">job_queue_processes                  integer     4000</span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>必须大于0，否则执行下面的命令修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system set job_queue_processes=10;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-8-再创建一个任务-每5分钟执行一次"><a href="#4-4-8-再创建一个任务-每5分钟执行一次" class="headerlink" title="4.4.8 再创建一个任务(每5分钟执行一次)"></a>4.4.8 再创建一个任务(每5分钟执行一次)</h3><p><strong>创建</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable jobno number;</span><br><span class="line">begin</span><br><span class="line"> dbms_job.submit(:jobno, &apos;proce_t;&apos;, sysdate, &apos;sysdate+1/24/12&apos;); --interval是以天为单位的</span><br><span class="line"> commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure></p><p><strong>执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select job,next_date,next_sec,failures,broken from user_jobs;</span><br><span class="line"></span><br><span class="line">       JOB NEXT_DATE          NEXT_SEC                           FAILURES B</span><br><span class="line">---------- ------------------ -------------------------------- ---------- -</span><br><span class="line">         1 21-MAY-18          00:36:50                                  0 N</span><br><span class="line">         2 21-MAY-18          00:41:25                                  0 N</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure></p><h2 id="4-5-job运行时间的总结"><a href="#4-5-job运行时间的总结" class="headerlink" title="4.5 job运行时间的总结"></a>4.5 job运行时间的总结</h2><p>1:每分钟执行<br>Interval =&gt; TRUNC(sysdate,’mi’) + 1/(24<em>60)<br>2:每天定时执行<br>例如：每天的凌晨1点执行<br>Interval =&gt; TRUNC(sysdate) + 1 +1/(24)<br>3:每周定时执行<br>例如：每周一凌晨1点执行<br>Interval =&gt; TRUNC(next_day(sysdate,’星期一’))+1/24<br>4:每月定时执行<br>例如：每月1日凌晨1点执行<br>Interval =&gt;TRUNC(LAST_DAY(SYSDATE))+1+1/24<br>5:每季度定时执行<br>例如每季度的第一天凌晨1点执行<br>Interval =&gt; TRUNC(ADD_MONTHS(SYSDATE,3),’Q’) + 1/24<br>6:每半年定时执行<br>例如：每年7月1日和1月1日凌晨1点<br>Interval =&gt; ADD_MONTHS(trunc(sysdate,’yyyy’),6)+1/24<br>7:每年定时执行<br>例如：每年1月1日凌晨1点执行<br>Interval =&gt;ADD_MONTHS(trunc(sysdate,’yyyy’), 12)+1/24<br>job的运行频率设置<br>1.每天固定时间运行，比如早上8:10分钟：Trunc(Sysdate+1) + (8</em>60+10)/24<em>60<br>2.Toad中提供的：<br>每天：trunc(sysdate+1)<br>每周：trunc(sysdate+7)<br>每月：trunc(sysdate+30)<br>每个星期日：next_day(trunc(sysdate),’星期日’)<br>每天6点：trunc(sysdate+1)+6/24<br>半个小时：sysdate+30/(24</em>60)<br>3.每个小时的第15分钟运行，比如：8:15，9:15，10:15…：trunc(sysdate,’hh’)+(60+15)/(24*60) 。</p><p><strong><em>上文参见：</em></strong><br>oracle数据库定时任务dbms_job的用法详解<br><a href="http://www.jb51.net/article/92575.htm" target="_blank" rel="noopener">http://www.jb51.net/article/92575.htm</a></p><p><strong><em>更多详情可参见以下两篇文章，有关于CHANGE的介绍。</em></strong></p><p><em>更多dbms_job包的说明：</em><br><a href="http://wallimn.iteye.com/blog/519924" target="_blank" rel="noopener">http://wallimn.iteye.com/blog/519924</a></p><p><strong>PS:</strong><br>change实际就是改变当前某个job设置的工作参数，包括job、what、next_date和interval参数。<br>job参数是一个整数值，它唯一标识此工作。<br>what参数是由此工作运行的一块PL/SQL代码块。<br>next_date参数指示何时此工作将被执行。<br>interval参数指示一个工作重执行的频度。</p><p><em>关于一些参数的解释可以参照一下：</em><br><a href="https://www.cnblogs.com/chenjunjie/p/5054415.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenjunjie/p/5054415.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/oracle_12c.jpg&quot; alt=&quot;oracle12c&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://xiejing2014.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://xiejing2014.github.io/tags/oracle/"/>
    
      <category term="oracle function" scheme="http://xiejing2014.github.io/tags/oracle-function/"/>
    
  </entry>
  
  <entry>
    <title>用不同语言来遍历目录和文件</title>
    <link href="http://xiejing2014.github.io/2018/05/18/%E7%94%A8%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E6%9D%A5%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6/"/>
    <id>http://xiejing2014.github.io/2018/05/18/用不同语言来遍历目录和文件/</id>
    <published>2018-05-18T02:28:15.000Z</published>
    <updated>2018-05-21T17:22:57.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/thanks_for_watching.jpg" alt=""></p><a id="more"></a><p>最近翻移动硬盘，发现自己还短暂的写过两个月的perl语言，盘中赫然躺着一些perl脚本，其中一个便是实现的遍历目录及其包含的文件的脚本。<br>该功能无非就是利用递归来写代码，这里想用perl、python、shell和C语言分别对其进行编写，聊发少年狂而已。</p><h1 id="1、程序列表"><a href="#1、程序列表" class="headerlink" title="1、程序列表"></a>1、程序列表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost script]# ls -tlr</span><br><span class="line">total 28</span><br><span class="line">-rwxr--r--. 1 root root  276 May 17 19:16 shell_find.sh</span><br><span class="line">-rwxr--r--. 1 root root  444 May 17 19:17 python_find.py</span><br><span class="line">-rwxr--r--. 1 root root  782 May 17 19:18 perl_find.sh</span><br><span class="line">-rw-r--r--. 1 root root 1184 May 17 19:36 C_Find.c</span><br><span class="line">-rwxr-xr-x. 1 root root 9048 May 17 19:37 C_Find</span><br><span class="line">[root@localhost script]#</span><br></pre></td></tr></table></figure><h2 id="1-1-perl"><a href="#1-1-perl" class="headerlink" title="1.1 perl"></a>1.1 perl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/perl</span><br><span class="line"></span><br><span class="line">use strict;</span><br><span class="line"></span><br><span class="line">my @filelist;</span><br><span class="line">my $dir = &quot;../python&quot;;</span><br><span class="line"></span><br><span class="line">push(@filelist,&amp;findfile($dir));</span><br><span class="line">print join(&quot;\n&quot;,@filelist);</span><br><span class="line">print &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">sub findfile&#123;</span><br><span class="line">        my @filelist;</span><br><span class="line">        my $dir = $_[0];</span><br><span class="line">        opendir(DIR,$dir);</span><br><span class="line">        my @temp = grep(!/^\.\.?$/,readdir(DIR));</span><br><span class="line">        close(DIR);</span><br><span class="line">        my $count = @temp;</span><br><span class="line">        my $i; </span><br><span class="line">        my $tmpdir;</span><br><span class="line">        for($i = 0; $i &lt; $count; $i++)&#123;</span><br><span class="line">                $tmpdir = (); </span><br><span class="line">                $tmpdir = &quot;$dir/$temp[$i]&quot;;</span><br><span class="line">                if(-d &quot;$tmpdir&quot;)&#123;</span><br><span class="line">                        push(@filelist,$tmpdir);                                                                                                                                             </span><br><span class="line">                        push(@filelist,&amp;findfile(&quot;$tmpdir&quot;));</span><br><span class="line">                &#125;   </span><br><span class="line">                else &#123;</span><br><span class="line">                        push(@filelist,$tmpdir);</span><br><span class="line">                &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        return @filelist;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-python"><a href="#1-2-python" class="headerlink" title="1.2 python"></a>1.2 python</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/python3</span><br><span class="line"># coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">basedir = &apos;../python&apos;</span><br><span class="line">filelists = []</span><br><span class="line"></span><br><span class="line">def find(basedir):</span><br><span class="line">    global filelists</span><br><span class="line">    for parent,dirnames,filenames in os.walk(basedir):</span><br><span class="line">        for dirname in dirnames:</span><br><span class="line">            filelists.append(os.path.join(parent,dirname))                                                                                                                                   </span><br><span class="line">        for filename in filenames:</span><br><span class="line">            filelists.append(os.path.join(parent,filename))</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    find(basedir)</span><br><span class="line">    print(&apos;\n&apos;.join(filelists))</span><br></pre></td></tr></table></figure><h2 id="1-3-shell"><a href="#1-3-shell" class="headerlink" title="1.3 shell"></a>1.3 shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/bash</span><br><span class="line"></span><br><span class="line">set -o nounset</span><br><span class="line">set -o errexit</span><br><span class="line"></span><br><span class="line">function find()&#123;</span><br><span class="line">    for file in `ls $1`</span><br><span class="line">    do  </span><br><span class="line">        if [ -d $1&quot;/&quot;$file ]</span><br><span class="line">        then</span><br><span class="line">            echo $1&quot;/&quot;$file                                                                                                                                                                  </span><br><span class="line">            find $1&quot;/&quot;$file</span><br><span class="line">        else</span><br><span class="line">            echo $1&quot;/&quot;$file</span><br><span class="line">        fi  </span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find &quot;../python&quot;</span><br></pre></td></tr></table></figure><h2 id="1-4-C"><a href="#1-4-C" class="headerlink" title="1.4 C"></a>1.4 C</h2><p>源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/* list dir and files through C */                                                                                                                                                           </span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_PATH_LENGTH 512 </span><br><span class="line"></span><br><span class="line">int find(char *path)</span><br><span class="line">&#123;</span><br><span class="line">    DIR *ptr_dir;</span><br><span class="line">    struct dirent *dir_entry;</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line">    char *child_path;</span><br><span class="line"></span><br><span class="line">    child_path = (char*)malloc(sizeof(char)*MAX_PATH_LENGTH);</span><br><span class="line">    if(child_path == NULL)&#123;</span><br><span class="line">        printf(&quot;malloc child_path occurs errors.\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    memset(child_path,0x0,sizeof(char)*MAX_PATH_LENGTH);</span><br><span class="line"></span><br><span class="line">    ptr_dir = opendir(path);</span><br><span class="line">    while(( dir_entry = readdir(ptr_dir) ) != NULL)&#123;</span><br><span class="line">        if(dir_entry-&gt;d_type &amp; DT_DIR)&#123;</span><br><span class="line">            if(strcmp(dir_entry-&gt;d_name,&quot;.&quot;) == 0 ||  </span><br><span class="line">                    strcmp(dir_entry-&gt;d_name,&quot;..&quot;) == 0)&#123; </span><br><span class="line">                continue;</span><br><span class="line">            &#125;   </span><br><span class="line">            sprintf(child_path,&quot;%s/%s&quot;,path,dir_entry-&gt;d_name);</span><br><span class="line">            printf(&quot;%s\n&quot;,child_path);</span><br><span class="line">    </span><br><span class="line">            find(child_path);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%s/%s\n&quot;,path,dir_entry-&gt;d_name);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    free(child_path);</span><br><span class="line">    child_path = NULL;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    find(&quot;../python&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o C_Find C_Find.c</span><br></pre></td></tr></table></figure></p><h1 id="2、执行结果"><a href="#2、执行结果" class="headerlink" title="2、执行结果"></a>2、执行结果</h1><p>上述代码执行结果一致，输出文件列表的默认排序或有差别。<br>以shell脚本的执行结果为例，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost script]# ./shell_find.sh </span><br><span class="line">../python/countCodeLine2.py</span><br><span class="line">../python/countCodeLine.py</span><br><span class="line">../python/countCodeLine.py_ori</span><br><span class="line">../python/Django</span><br><span class="line">../python/How_to_be_pythonic</span><br><span class="line">../python/How_to_be_pythonic/add.c</span><br><span class="line">../python/How_to_be_pythonic/adder.so</span><br><span class="line">../python/How_to_be_pythonic/app_decrator.py</span><br><span class="line">../python/How_to_be_pythonic/cpython_api.py</span><br><span class="line">../python/How_to_be_pythonic/cpython_ctype.py</span><br><span class="line">../python/How_to_be_pythonic/cpython_SWIG.py</span><br><span class="line">../python/How_to_be_pythonic/debug.txt</span><br><span class="line">../python/How_to_be_pythonic/decrator.py</span><br><span class="line">../python/How_to_be_pythonic/def__.py</span><br><span class="line">../python/How_to_be_pythonic/enumerate.py</span><br><span class="line">../python/How_to_be_pythonic/exception.py</span><br><span class="line">../python/How_to_be_pythonic/forelse.py</span><br><span class="line">../python/How_to_be_pythonic/funccode1.py</span><br><span class="line">../python/How_to_be_pythonic/Generators.py</span><br><span class="line">../python/How_to_be_pythonic/kw-args.py</span><br><span class="line">../python/How_to_be_pythonic/out.log</span><br><span class="line">../python/How_to_be_pythonic/pprint.py</span><br><span class="line">../python/How_to_be_pythonic/set.py</span><br><span class="line">../python/How_to_be_pythonic/test3.py</span><br><span class="line">../python/How_to_be_pythonic/test.py</span><br><span class="line">[root@localhost script]#</span><br></pre></td></tr></table></figure></p><h1 id="3、后记"><a href="#3、后记" class="headerlink" title="3、后记"></a>3、后记</h1><ol><li>C语言的实现方法中，有关dirent、stat等结构体含义的描述，可参见：<br> <a href="http://www.360doc.com/content/15/0701/10/5470123_481878714.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/15/0701/10/5470123_481878714.shtml</a></li><li>代码中输出的是目录及文件，可调整。</li><li>对列出的文件可做进一步的条件筛选，如后缀判断等。</li><li>可比较时间，可优化。</li><li>本文原作者:不出名的刀客，转载请一同转发本文链接。</li><li>第一次网上写技术文，文有不对之处，欢迎指正。</li><li>另，小白正在学习python，欢迎大神留言指教。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/thanks_for_watching.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发经验" scheme="http://xiejing2014.github.io/categories/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="perl" scheme="http://xiejing2014.github.io/tags/perl/"/>
    
      <category term="python" scheme="http://xiejing2014.github.io/tags/python/"/>
    
      <category term="shell" scheme="http://xiejing2014.github.io/tags/shell/"/>
    
      <category term="C/C++" scheme="http://xiejing2014.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
